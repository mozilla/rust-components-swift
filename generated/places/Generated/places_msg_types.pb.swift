// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: places_msg_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Protobuf allows nesting these, but prost behaves weirdly if we do.
enum MsgTypes_SearchResultReason: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Never used in practice. Maybe remove this from here and from the rust enum?
  case keyword // = 1
  case origin // = 2
  case url // = 3
  case previousUse // = 4
  case bookmark // = 5

  /// If we get real tag support, just add `optional string tags` to SearchResult below, but
  /// for now expose that it was because of tags.
  case tag // = 6

  init() {
    self = .keyword
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .keyword
    case 2: self = .origin
    case 3: self = .url
    case 4: self = .previousUse
    case 5: self = .bookmark
    case 6: self = .tag
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .keyword: return 1
    case .origin: return 2
    case .url: return 3
    case .previousUse: return 4
    case .bookmark: return 5
    case .tag: return 6
    }
  }

}

#if swift(>=4.2)

extension MsgTypes_SearchResultReason: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct MsgTypes_HistoryVisitInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var timestamp: Int64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var visitType: Int32 {
    get {return _visitType ?? 0}
    set {_visitType = newValue}
  }
  /// Returns true if `visitType` has been explicitly set.
  var hasVisitType: Bool {return self._visitType != nil}
  /// Clears the value of `visitType`. Subsequent reads from it will return its default value.
  mutating func clearVisitType() {self._visitType = nil}

  var isHidden: Bool {
    get {return _isHidden ?? false}
    set {_isHidden = newValue}
  }
  /// Returns true if `isHidden` has been explicitly set.
  var hasIsHidden: Bool {return self._isHidden != nil}
  /// Clears the value of `isHidden`. Subsequent reads from it will return its default value.
  mutating func clearIsHidden() {self._isHidden = nil}

  var previewImageURL: String {
    get {return _previewImageURL ?? String()}
    set {_previewImageURL = newValue}
  }
  /// Returns true if `previewImageURL` has been explicitly set.
  var hasPreviewImageURL: Bool {return self._previewImageURL != nil}
  /// Clears the value of `previewImageURL`. Subsequent reads from it will return its default value.
  mutating func clearPreviewImageURL() {self._previewImageURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _url: String? = nil
  fileprivate var _title: String? = nil
  fileprivate var _timestamp: Int64? = nil
  fileprivate var _visitType: Int32? = nil
  fileprivate var _isHidden: Bool? = nil
  fileprivate var _previewImageURL: String? = nil
}

struct MsgTypes_HistoryVisitInfos {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var infos: [MsgTypes_HistoryVisitInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MsgTypes_HistoryVisitInfosWithBound {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var infos: [MsgTypes_HistoryVisitInfo] = []

  var bound: Int64 {
    get {return _bound ?? 0}
    set {_bound = newValue}
  }
  /// Returns true if `bound` has been explicitly set.
  var hasBound: Bool {return self._bound != nil}
  /// Clears the value of `bound`. Subsequent reads from it will return its default value.
  mutating func clearBound() {self._bound = nil}

  var offset: Int64 {
    get {return _offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {self._offset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bound: Int64? = nil
  fileprivate var _offset: Int64? = nil
}

///*
/// A bookmark node.
///
/// We use a single message type for bookmarks. It covers insertion, deletion,
/// and update, and represents all three bookmark types.
///
/// This simplifies the FFI by reducing the number of types that must go across
/// it, and retuces boilderplate, but removes some static-ish guarantees we
/// might have otherwise.
///
/// Note that these docs comments are internal, and don't necessarily impact the actual
/// API we expose to Kotlin/Swift (this is particularly true around reads).
struct MsgTypes_BookmarkNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The type of this bookmark, a `BookmarkType` (from `types.rs`).
  ///
  /// This impacts which fields may be present.
  ///
  /// It's illegal to attempt to change this when updating a bookmark.
  ///
  /// Note: this probably should be an `enum`, but prost seems to get upset
  /// about it so we're just using int32 for now.
  ///
  /// Note: this is `node_type` and not `type` because `type` is reserved
  /// in Rust.
  ///
  /// - Always returned on reads.
  /// - Required for inserts.
  /// - Not provided for updates.
  var nodeType: Int32 {
    get {return _nodeType ?? 0}
    set {_nodeType = newValue}
  }
  /// Returns true if `nodeType` has been explicitly set.
  var hasNodeType: Bool {return self._nodeType != nil}
  /// Clears the value of `nodeType`. Subsequent reads from it will return its default value.
  mutating func clearNodeType() {self._nodeType = nil}

  ///*
  /// The bookmarks guid.
  ///
  /// - Always returned on reads.
  /// - Not allowed for inserts.
  /// - Required for updates (specifies which record is being changed)
  var guid: String {
    get {return _guid ?? String()}
    set {_guid = newValue}
  }
  /// Returns true if `guid` has been explicitly set.
  var hasGuid: Bool {return self._guid != nil}
  /// Clears the value of `guid`. Subsequent reads from it will return its default value.
  mutating func clearGuid() {self._guid = nil}

  ///*
  /// Creation time, in milliseconds since the unix epoch.
  ///
  /// May not be a local timestamp, and may shift if new devices are able to
  /// provide an earlier (but still valid) timestamp.
  ///
  /// - Always returned on reads.
  /// - Ignored for insertion and update.
  var dateAdded: Int64 {
    get {return _dateAdded ?? 0}
    set {_dateAdded = newValue}
  }
  /// Returns true if `dateAdded` has been explicitly set.
  var hasDateAdded: Bool {return self._dateAdded != nil}
  /// Clears the value of `dateAdded`. Subsequent reads from it will return its default value.
  mutating func clearDateAdded() {self._dateAdded = nil}

  ///*
  /// Last modification time, in milliseconds since the unix epoch.
  ///
  /// - Always returned on reads.
  /// - Ignored for insertion and update.
  var lastModified: Int64 {
    get {return _lastModified ?? 0}
    set {_lastModified = newValue}
  }
  /// Returns true if `lastModified` has been explicitly set.
  var hasLastModified: Bool {return self._lastModified != nil}
  /// Clears the value of `lastModified`. Subsequent reads from it will return its default value.
  mutating func clearLastModified() {self._lastModified = nil}

  ///*
  /// Guid of the parent record.
  ///
  /// - Returned on reads, except for reads of the bookmark root.
  /// - Required for insertion.
  /// - On updates, if provided, we treat it as a move.
  ///     - Interacts with `position`, see its documentation below
  ///       for details on how.
  var parentGuid: String {
    get {return _parentGuid ?? String()}
    set {_parentGuid = newValue}
  }
  /// Returns true if `parentGuid` has been explicitly set.
  var hasParentGuid: Bool {return self._parentGuid != nil}
  /// Clears the value of `parentGuid`. Subsequent reads from it will return its default value.
  mutating func clearParentGuid() {self._parentGuid = nil}

  ///*
  /// Zero based index within the parent.
  ///
  /// - Not provided on reads (for now).
  ///
  /// - Allowed for insertion.
  ///    - Leaving it out means 'end of folder'.
  ///
  /// - Allowed for updates.
  ///     - If `parent_guid` is not provided and `position` is, we treat this
  ///       a move within the same folder.
  ///
  ///     - If `parent_guid` and `position` are both provided, we treat this as
  ///       a move to / within that folder, and we insert at the requested
  ///       position.
  ///
  ///     - If `position` is not provided (and `parent_guid` is) then it's
  ///       treated as a move to the end of that folder.
  var position: UInt32 {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  ///*
  /// Bookmark title. Not present for type = `BookmarkType::Separator`.
  ///
  /// - Returned on reads if it exists.
  /// - Required when inserting folders.
  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  ///*
  /// Bookmark URL. Only allowed/present for type = `BookmarkType::Bookmark`.
  ///
  /// - Always returned on reads (for `BookmarkType::Bookmark`).
  /// - Required when inserting a new bookmark.
  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  ///*
  /// IDs of folder children, in order. Only present for type =
  /// `BookmarkType::Folder`.
  ///
  /// - Returned on reads (for `BookmarkType::Folder`).
  /// - Forbidden for insertions and updates.
  /// - Not provided if `child_nodes` is provided, to avoid sending more data
  ///   over the FFI than necessary.
  var childGuids: [String] = []

  ///*
  /// Data about folder children, in order. Only present for type =
  /// `BookmarkType::Folder`.
  ///
  /// For performance reasons, this only is provided if it's requested.
  var childNodes: [MsgTypes_BookmarkNode] = []

  ///*
  /// Returned by reads, and used to distinguish between the cases of
  /// "empty child_nodes because the API doesn't return children" and
  /// "empty child_nodes because this folder has no children (but
  /// we'd populate them if it had them)".
  ///
  /// Only required because you can't have `optional repeated`.
  ///
  /// Leaving this out is equivalent to false.
  var haveChildNodes: Bool {
    get {return _haveChildNodes ?? false}
    set {_haveChildNodes = newValue}
  }
  /// Returns true if `haveChildNodes` has been explicitly set.
  var hasHaveChildNodes: Bool {return self._haveChildNodes != nil}
  /// Clears the value of `haveChildNodes`. Subsequent reads from it will return its default value.
  mutating func clearHaveChildNodes() {self._haveChildNodes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nodeType: Int32? = nil
  fileprivate var _guid: String? = nil
  fileprivate var _dateAdded: Int64? = nil
  fileprivate var _lastModified: Int64? = nil
  fileprivate var _parentGuid: String? = nil
  fileprivate var _position: UInt32? = nil
  fileprivate var _title: String? = nil
  fileprivate var _url: String? = nil
  fileprivate var _haveChildNodes: Bool? = nil
}

///* An array of bookmark nodes, since we can't represent that directly 
struct MsgTypes_BookmarkNodeList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodes: [MsgTypes_BookmarkNode] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MsgTypes_SearchResultMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var frecency: Int64 {
    get {return _frecency ?? 0}
    set {_frecency = newValue}
  }
  /// Returns true if `frecency` has been explicitly set.
  var hasFrecency: Bool {return self._frecency != nil}
  /// Clears the value of `frecency`. Subsequent reads from it will return its default value.
  mutating func clearFrecency() {self._frecency = nil}

  var reasons: [MsgTypes_SearchResultReason] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _url: String? = nil
  fileprivate var _title: String? = nil
  fileprivate var _frecency: Int64? = nil
}

struct MsgTypes_SearchResultList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var results: [MsgTypes_SearchResultMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MsgTypes_TopFrecentSiteInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _url: String? = nil
  fileprivate var _title: String? = nil
}

struct MsgTypes_TopFrecentSiteInfos {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var infos: [MsgTypes_TopFrecentSiteInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mozilla.appservices.places.protobuf"

extension MsgTypes_SearchResultReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "KEYWORD"),
    2: .same(proto: "ORIGIN"),
    3: .same(proto: "URL"),
    4: .same(proto: "PREVIOUS_USE"),
    5: .same(proto: "BOOKMARK"),
    6: .same(proto: "TAG"),
  ]
}

extension MsgTypes_HistoryVisitInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HistoryVisitInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "timestamp"),
    4: .standard(proto: "visit_type"),
    5: .standard(proto: "is_hidden"),
    6: .standard(proto: "preview_image_url"),
  ]

  public var isInitialized: Bool {
    if self._url == nil {return false}
    if self._timestamp == nil {return false}
    if self._visitType == nil {return false}
    if self._isHidden == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._timestamp) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._visitType) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._isHidden) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._previewImageURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._visitType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._isHidden {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._previewImageURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgTypes_HistoryVisitInfo, rhs: MsgTypes_HistoryVisitInfo) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._title != rhs._title {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._visitType != rhs._visitType {return false}
    if lhs._isHidden != rhs._isHidden {return false}
    if lhs._previewImageURL != rhs._previewImageURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgTypes_HistoryVisitInfos: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HistoryVisitInfos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "infos"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.infos) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.infos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgTypes_HistoryVisitInfos, rhs: MsgTypes_HistoryVisitInfos) -> Bool {
    if lhs.infos != rhs.infos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgTypes_HistoryVisitInfosWithBound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HistoryVisitInfosWithBound"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "infos"),
    2: .same(proto: "bound"),
    3: .same(proto: "offset"),
  ]

  public var isInitialized: Bool {
    if self._bound == nil {return false}
    if self._offset == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.infos) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infos) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._bound) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.infos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infos, fieldNumber: 1)
    }
    try { if let v = self._bound {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._offset {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgTypes_HistoryVisitInfosWithBound, rhs: MsgTypes_HistoryVisitInfosWithBound) -> Bool {
    if lhs.infos != rhs.infos {return false}
    if lhs._bound != rhs._bound {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgTypes_BookmarkNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BookmarkNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_type"),
    2: .same(proto: "guid"),
    3: .standard(proto: "date_added"),
    4: .standard(proto: "last_modified"),
    5: .standard(proto: "parent_guid"),
    6: .same(proto: "position"),
    7: .same(proto: "title"),
    8: .same(proto: "url"),
    9: .standard(proto: "child_guids"),
    10: .standard(proto: "child_nodes"),
    11: .standard(proto: "have_child_nodes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._nodeType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._guid) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._dateAdded) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._lastModified) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._parentGuid) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._position) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.childGuids) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.childNodes) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self._haveChildNodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._guid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dateAdded {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lastModified {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._parentGuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._position {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    if !self.childGuids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.childGuids, fieldNumber: 9)
    }
    if !self.childNodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childNodes, fieldNumber: 10)
    }
    try { if let v = self._haveChildNodes {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgTypes_BookmarkNode, rhs: MsgTypes_BookmarkNode) -> Bool {
    if lhs._nodeType != rhs._nodeType {return false}
    if lhs._guid != rhs._guid {return false}
    if lhs._dateAdded != rhs._dateAdded {return false}
    if lhs._lastModified != rhs._lastModified {return false}
    if lhs._parentGuid != rhs._parentGuid {return false}
    if lhs._position != rhs._position {return false}
    if lhs._title != rhs._title {return false}
    if lhs._url != rhs._url {return false}
    if lhs.childGuids != rhs.childGuids {return false}
    if lhs.childNodes != rhs.childNodes {return false}
    if lhs._haveChildNodes != rhs._haveChildNodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgTypes_BookmarkNodeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BookmarkNodeList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgTypes_BookmarkNodeList, rhs: MsgTypes_BookmarkNodeList) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgTypes_SearchResultMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SearchResultMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "frecency"),
    4: .same(proto: "reasons"),
  ]

  public var isInitialized: Bool {
    if self._url == nil {return false}
    if self._title == nil {return false}
    if self._frecency == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._frecency) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.reasons) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._frecency {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    if !self.reasons.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasons, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgTypes_SearchResultMessage, rhs: MsgTypes_SearchResultMessage) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._title != rhs._title {return false}
    if lhs._frecency != rhs._frecency {return false}
    if lhs.reasons != rhs.reasons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgTypes_SearchResultList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SearchResultList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.results) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgTypes_SearchResultList, rhs: MsgTypes_SearchResultList) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgTypes_TopFrecentSiteInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopFrecentSiteInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
  ]

  public var isInitialized: Bool {
    if self._url == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgTypes_TopFrecentSiteInfo, rhs: MsgTypes_TopFrecentSiteInfo) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._title != rhs._title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgTypes_TopFrecentSiteInfos: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopFrecentSiteInfos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "infos"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.infos) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.infos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgTypes_TopFrecentSiteInfos, rhs: MsgTypes_TopFrecentSiteInfos) -> Bool {
    if lhs.infos != rhs.infos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
