// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(MozillaRustComponents)
    import MozillaRustComponents
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            try! rustCall { ffi_nimbus_1c8c_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_nimbus_1c8c_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// A helper class to read values out of a byte buffer.
private class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset ..< offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        _ = withUnsafeMutableBytes(of: &value) { data.copyBytes(to: $0, from: range) }
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads an arbitrary number of bytes, to be used to read
    // raw bytes, this is useful when lifting strings
    func readBytes(count: Int) throws -> [UInt8] {
        let range = offset ..< (offset + count)
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        var value = [UInt8](repeating: 0, count: count)
        value.withUnsafeMutableBufferPointer { buffer in
            data.copyBytes(to: buffer, from: range)
        }
        offset = range.upperBound
        return value
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
private class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        bytes = []
        offset = 0
    }

    func writeBytes<S>(_ byteArr: S) where S: Sequence, S.Element == UInt8 {
        bytes.append(contentsOf: byteArr)
    }

    // Writes an integer in big-endian order.
    //
    // Warning: make sure what you are trying to write
    // is in the correct type!
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        withUnsafeBytes(of: &value) { bytes.append(contentsOf: $0) }
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}

// Types conforming to `Serializable` can be read and written in a bytebuffer.
private protocol Serializable {
    func write(into: Writer)
    static func read(from: Reader) throws -> Self
}

// Types confirming to `ViaFfi` can be transferred back-and-for over the FFI.
// This is analogous to the Rust trait of the same name.
private protocol ViaFfi: Serializable {
    associatedtype FfiType
    static func lift(_ v: FfiType) throws -> Self
    func lower() -> FfiType
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol Primitive {}

private extension Primitive {
    typealias FfiType = Self

    static func lift(_ v: Self) throws -> Self {
        return v
    }

    func lower() -> Self {
        return self
    }
}

// Types conforming to `ViaFfiUsingByteBuffer` lift and lower into a bytebuffer.
// Use this for complex types where it's hard to write a custom lift/lower.
private protocol ViaFfiUsingByteBuffer: Serializable {}

private extension ViaFfiUsingByteBuffer {
    typealias FfiType = RustBuffer

    static func lift(_ buf: RustBuffer) throws -> Self {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try Self.read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    func lower() -> RustBuffer {
        let writer = Writer()
        write(into: writer)
        return RustBuffer(bytes: writer.bytes)
    }
}

// Implement our protocols for the built-in types that we use.

extension Optional: ViaFfiUsingByteBuffer, ViaFfi, Serializable where Wrapped: Serializable {
    fileprivate static func read(from buf: Reader) throws -> Self {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try Wrapped.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }

    fileprivate func write(into buf: Writer) {
        guard let value = self else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        value.write(into: buf)
    }
}

extension Array: ViaFfiUsingByteBuffer, ViaFfi, Serializable where Element: Serializable {
    fileprivate static func read(from buf: Reader) throws -> Self {
        let len: Int32 = try buf.readInt()
        var seq = [Element]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try Element.read(from: buf))
        }
        return seq
    }

    fileprivate func write(into buf: Writer) {
        let len = Int32(count)
        buf.writeInt(len)
        for item in self {
            item.write(into: buf)
        }
    }
}

extension Dictionary: ViaFfiUsingByteBuffer, ViaFfi, Serializable where Key == String, Value: Serializable {
    fileprivate static func read(from buf: Reader) throws -> Self {
        let len: Int32 = try buf.readInt()
        var dict = [String: Value]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            dict[try String.read(from: buf)] = try Value.read(from: buf)
        }
        return dict
    }

    fileprivate func write(into buf: Writer) {
        let len = Int32(count)
        buf.writeInt(len)
        for (key, value) in self {
            key.write(into: buf)
            value.write(into: buf)
        }
    }
}

extension Int8: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Int8 {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension Int32: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Int32 {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension Bool: ViaFfi {
    fileprivate typealias FfiType = Int8

    fileprivate static func read(from buf: Reader) throws -> Bool {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }

    fileprivate static func lift(_ v: Int8) throws -> Bool {
        return v != 0
    }

    fileprivate func lower() -> Int8 {
        return self ? 1 : 0
    }
}

extension String: ViaFfi {
    fileprivate typealias FfiType = RustBuffer

    fileprivate static func lift(_ v: FfiType) throws -> Self {
        defer {
            try! rustCall { ffi_nimbus_1c8c_rustbuffer_free(v, $0) }
        }
        if v.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: v.data!, count: Int(v.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    fileprivate func lower() -> FfiType {
        return utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                let bytes = ForeignBytes(bufferPointer: buf)
                return try! rustCall { ffi_nimbus_1c8c_rustbuffer_from_bytes(bytes, $0) }
            }
        }
    }

    fileprivate static func read(from buf: Reader) throws -> Self {
        let len: Int32 = try buf.readInt()
        return String(bytes: try buf.readBytes(count: Int(len)), encoding: String.Encoding.utf8)!
    }

    fileprivate func write(into buf: Writer) {
        let len = Int32(utf8.count)
        buf.writeInt(len)
        buf.writeBytes(utf8)
    }
}

// Public interface members begin here.

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EnrollmentChangeEventType {
    case enrollment
    case disqualification
    case unenrollment
}

extension EnrollmentChangeEventType: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> EnrollmentChangeEventType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .enrollment
        case 2: return .disqualification
        case 3: return .unenrollment
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .enrollment:
            buf.writeInt(Int32(1))

        case .disqualification:
            buf.writeInt(Int32(2))

        case .unenrollment:
            buf.writeInt(Int32(3))
        }
    }
}

extension EnrollmentChangeEventType: Equatable, Hashable {}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

public enum NimbusError {
    case InvalidPersistedData
    case RkvError
    case IoError
    case JsonError
    case EvaluationError
    case InvalidExpression
    case InvalidFraction
    case TryFromSliceError
    case EmptyRatiosError
    case OutOfBoundsError
    case UrlParsingError
    case RequestError
    case ResponseError
    case UuidError
    case InvalidExperimentFormat
    case InvalidPath
    case InternalError
    case NoSuchExperiment
    case NoSuchBranch
    case BackoffError
    case DatabaseNotReady
}

extension NimbusError: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> NimbusError {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .InvalidPersistedData
        case 2: return .RkvError
        case 3: return .IoError
        case 4: return .JsonError
        case 5: return .EvaluationError
        case 6: return .InvalidExpression
        case 7: return .InvalidFraction
        case 8: return .TryFromSliceError
        case 9: return .EmptyRatiosError
        case 10: return .OutOfBoundsError
        case 11: return .UrlParsingError
        case 12: return .RequestError
        case 13: return .ResponseError
        case 14: return .UuidError
        case 15: return .InvalidExperimentFormat
        case 16: return .InvalidPath
        case 17: return .InternalError
        case 18: return .NoSuchExperiment
        case 19: return .NoSuchBranch
        case 20: return .BackoffError
        case 21: return .DatabaseNotReady
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .InvalidPersistedData:
            buf.writeInt(Int32(1))

        case .RkvError:
            buf.writeInt(Int32(2))

        case .IoError:
            buf.writeInt(Int32(3))

        case .JsonError:
            buf.writeInt(Int32(4))

        case .EvaluationError:
            buf.writeInt(Int32(5))

        case .InvalidExpression:
            buf.writeInt(Int32(6))

        case .InvalidFraction:
            buf.writeInt(Int32(7))

        case .TryFromSliceError:
            buf.writeInt(Int32(8))

        case .EmptyRatiosError:
            buf.writeInt(Int32(9))

        case .OutOfBoundsError:
            buf.writeInt(Int32(10))

        case .UrlParsingError:
            buf.writeInt(Int32(11))

        case .RequestError:
            buf.writeInt(Int32(12))

        case .ResponseError:
            buf.writeInt(Int32(13))

        case .UuidError:
            buf.writeInt(Int32(14))

        case .InvalidExperimentFormat:
            buf.writeInt(Int32(15))

        case .InvalidPath:
            buf.writeInt(Int32(16))

        case .InternalError:
            buf.writeInt(Int32(17))

        case .NoSuchExperiment:
            buf.writeInt(Int32(18))

        case .NoSuchBranch:
            buf.writeInt(Int32(19))

        case .BackoffError:
            buf.writeInt(Int32(20))

        case .DatabaseNotReady:
            buf.writeInt(Int32(21))
        }
    }
}

extension NimbusError: Equatable, Hashable {}

extension NimbusError: Error {}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, E: ViaFfiUsingByteBuffer & Error>(_: E.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: { try E.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw UniffiInternalError.rustPanic(try String.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

public struct AppContext {
    public var appName: String
    public var appId: String
    public var channel: String
    public var appVersion: String?
    public var appBuild: String?
    public var architecture: String?
    public var deviceManufacturer: String?
    public var deviceModel: String?
    public var locale: String?
    public var os: String?
    public var osVersion: String?
    public var androidSdkVersion: String?
    public var debugTag: String?
    public var customTargetingAttributes: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(appName: String, appId: String, channel: String, appVersion: String?, appBuild: String?, architecture: String?, deviceManufacturer: String?, deviceModel: String?, locale: String?, os: String?, osVersion: String?, androidSdkVersion: String?, debugTag: String?, customTargetingAttributes: [String: String]?) {
        self.appName = appName
        self.appId = appId
        self.channel = channel
        self.appVersion = appVersion
        self.appBuild = appBuild
        self.architecture = architecture
        self.deviceManufacturer = deviceManufacturer
        self.deviceModel = deviceModel
        self.locale = locale
        self.os = os
        self.osVersion = osVersion
        self.androidSdkVersion = androidSdkVersion
        self.debugTag = debugTag
        self.customTargetingAttributes = customTargetingAttributes
    }
}

extension AppContext: Equatable, Hashable {
    public static func == (lhs: AppContext, rhs: AppContext) -> Bool {
        if lhs.appName != rhs.appName {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.channel != rhs.channel {
            return false
        }
        if lhs.appVersion != rhs.appVersion {
            return false
        }
        if lhs.appBuild != rhs.appBuild {
            return false
        }
        if lhs.architecture != rhs.architecture {
            return false
        }
        if lhs.deviceManufacturer != rhs.deviceManufacturer {
            return false
        }
        if lhs.deviceModel != rhs.deviceModel {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.os != rhs.os {
            return false
        }
        if lhs.osVersion != rhs.osVersion {
            return false
        }
        if lhs.androidSdkVersion != rhs.androidSdkVersion {
            return false
        }
        if lhs.debugTag != rhs.debugTag {
            return false
        }
        if lhs.customTargetingAttributes != rhs.customTargetingAttributes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(appName)
        hasher.combine(appId)
        hasher.combine(channel)
        hasher.combine(appVersion)
        hasher.combine(appBuild)
        hasher.combine(architecture)
        hasher.combine(deviceManufacturer)
        hasher.combine(deviceModel)
        hasher.combine(locale)
        hasher.combine(os)
        hasher.combine(osVersion)
        hasher.combine(androidSdkVersion)
        hasher.combine(debugTag)
        hasher.combine(customTargetingAttributes)
    }
}

private extension AppContext {
    static func read(from buf: Reader) throws -> AppContext {
        return try AppContext(
            appName: String.read(from: buf),
            appId: String.read(from: buf),
            channel: String.read(from: buf),
            appVersion: String?.read(from: buf),
            appBuild: String?.read(from: buf),
            architecture: String?.read(from: buf),
            deviceManufacturer: String?.read(from: buf),
            deviceModel: String?.read(from: buf),
            locale: String?.read(from: buf),
            os: String?.read(from: buf),
            osVersion: String?.read(from: buf),
            androidSdkVersion: String?.read(from: buf),
            debugTag: String?.read(from: buf),
            customTargetingAttributes: [String: String]?.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        appName.write(into: buf)
        appId.write(into: buf)
        channel.write(into: buf)
        appVersion.write(into: buf)
        appBuild.write(into: buf)
        architecture.write(into: buf)
        deviceManufacturer.write(into: buf)
        deviceModel.write(into: buf)
        locale.write(into: buf)
        os.write(into: buf)
        osVersion.write(into: buf)
        androidSdkVersion.write(into: buf)
        debugTag.write(into: buf)
        customTargetingAttributes.write(into: buf)
    }
}

extension AppContext: ViaFfiUsingByteBuffer, ViaFfi {}

public struct EnrolledExperiment {
    public var featureIds: [String]
    public var slug: String
    public var userFacingName: String
    public var userFacingDescription: String
    public var branchSlug: String
    public var enrollmentId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(featureIds: [String], slug: String, userFacingName: String, userFacingDescription: String, branchSlug: String, enrollmentId: String) {
        self.featureIds = featureIds
        self.slug = slug
        self.userFacingName = userFacingName
        self.userFacingDescription = userFacingDescription
        self.branchSlug = branchSlug
        self.enrollmentId = enrollmentId
    }
}

extension EnrolledExperiment: Equatable, Hashable {
    public static func == (lhs: EnrolledExperiment, rhs: EnrolledExperiment) -> Bool {
        if lhs.featureIds != rhs.featureIds {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.userFacingName != rhs.userFacingName {
            return false
        }
        if lhs.userFacingDescription != rhs.userFacingDescription {
            return false
        }
        if lhs.branchSlug != rhs.branchSlug {
            return false
        }
        if lhs.enrollmentId != rhs.enrollmentId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(featureIds)
        hasher.combine(slug)
        hasher.combine(userFacingName)
        hasher.combine(userFacingDescription)
        hasher.combine(branchSlug)
        hasher.combine(enrollmentId)
    }
}

private extension EnrolledExperiment {
    static func read(from buf: Reader) throws -> EnrolledExperiment {
        return try EnrolledExperiment(
            featureIds: [String].read(from: buf),
            slug: String.read(from: buf),
            userFacingName: String.read(from: buf),
            userFacingDescription: String.read(from: buf),
            branchSlug: String.read(from: buf),
            enrollmentId: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        featureIds.write(into: buf)
        slug.write(into: buf)
        userFacingName.write(into: buf)
        userFacingDescription.write(into: buf)
        branchSlug.write(into: buf)
        enrollmentId.write(into: buf)
    }
}

extension EnrolledExperiment: ViaFfiUsingByteBuffer, ViaFfi {}

public struct AvailableExperiment {
    public var slug: String
    public var userFacingName: String
    public var userFacingDescription: String
    public var branches: [ExperimentBranch]
    public var referenceBranch: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(slug: String, userFacingName: String, userFacingDescription: String, branches: [ExperimentBranch], referenceBranch: String?) {
        self.slug = slug
        self.userFacingName = userFacingName
        self.userFacingDescription = userFacingDescription
        self.branches = branches
        self.referenceBranch = referenceBranch
    }
}

extension AvailableExperiment: Equatable, Hashable {
    public static func == (lhs: AvailableExperiment, rhs: AvailableExperiment) -> Bool {
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.userFacingName != rhs.userFacingName {
            return false
        }
        if lhs.userFacingDescription != rhs.userFacingDescription {
            return false
        }
        if lhs.branches != rhs.branches {
            return false
        }
        if lhs.referenceBranch != rhs.referenceBranch {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(slug)
        hasher.combine(userFacingName)
        hasher.combine(userFacingDescription)
        hasher.combine(branches)
        hasher.combine(referenceBranch)
    }
}

private extension AvailableExperiment {
    static func read(from buf: Reader) throws -> AvailableExperiment {
        return try AvailableExperiment(
            slug: String.read(from: buf),
            userFacingName: String.read(from: buf),
            userFacingDescription: String.read(from: buf),
            branches: [ExperimentBranch].read(from: buf),
            referenceBranch: String?.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        slug.write(into: buf)
        userFacingName.write(into: buf)
        userFacingDescription.write(into: buf)
        branches.write(into: buf)
        referenceBranch.write(into: buf)
    }
}

extension AvailableExperiment: ViaFfiUsingByteBuffer, ViaFfi {}

public struct ExperimentBranch {
    public var slug: String
    public var ratio: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(slug: String, ratio: Int32) {
        self.slug = slug
        self.ratio = ratio
    }
}

extension ExperimentBranch: Equatable, Hashable {
    public static func == (lhs: ExperimentBranch, rhs: ExperimentBranch) -> Bool {
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.ratio != rhs.ratio {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(slug)
        hasher.combine(ratio)
    }
}

private extension ExperimentBranch {
    static func read(from buf: Reader) throws -> ExperimentBranch {
        return try ExperimentBranch(
            slug: String.read(from: buf),
            ratio: Int32.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        slug.write(into: buf)
        ratio.write(into: buf)
    }
}

extension ExperimentBranch: ViaFfiUsingByteBuffer, ViaFfi {}

public struct RemoteSettingsConfig {
    public var serverUrl: String
    public var collectionName: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(serverUrl: String, collectionName: String) {
        self.serverUrl = serverUrl
        self.collectionName = collectionName
    }
}

extension RemoteSettingsConfig: Equatable, Hashable {
    public static func == (lhs: RemoteSettingsConfig, rhs: RemoteSettingsConfig) -> Bool {
        if lhs.serverUrl != rhs.serverUrl {
            return false
        }
        if lhs.collectionName != rhs.collectionName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(serverUrl)
        hasher.combine(collectionName)
    }
}

private extension RemoteSettingsConfig {
    static func read(from buf: Reader) throws -> RemoteSettingsConfig {
        return try RemoteSettingsConfig(
            serverUrl: String.read(from: buf),
            collectionName: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        serverUrl.write(into: buf)
        collectionName.write(into: buf)
    }
}

extension RemoteSettingsConfig: ViaFfiUsingByteBuffer, ViaFfi {}

public struct AvailableRandomizationUnits {
    public var clientId: String?
    public var dummy: Int8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(clientId: String?, dummy: Int8) {
        self.clientId = clientId
        self.dummy = dummy
    }
}

extension AvailableRandomizationUnits: Equatable, Hashable {
    public static func == (lhs: AvailableRandomizationUnits, rhs: AvailableRandomizationUnits) -> Bool {
        if lhs.clientId != rhs.clientId {
            return false
        }
        if lhs.dummy != rhs.dummy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(clientId)
        hasher.combine(dummy)
    }
}

private extension AvailableRandomizationUnits {
    static func read(from buf: Reader) throws -> AvailableRandomizationUnits {
        return try AvailableRandomizationUnits(
            clientId: String?.read(from: buf),
            dummy: Int8.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        clientId.write(into: buf)
        dummy.write(into: buf)
    }
}

extension AvailableRandomizationUnits: ViaFfiUsingByteBuffer, ViaFfi {}

public struct EnrollmentChangeEvent {
    public var experimentSlug: String
    public var branchSlug: String
    public var enrollmentId: String
    public var reason: String?
    public var change: EnrollmentChangeEventType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(experimentSlug: String, branchSlug: String, enrollmentId: String, reason: String?, change: EnrollmentChangeEventType) {
        self.experimentSlug = experimentSlug
        self.branchSlug = branchSlug
        self.enrollmentId = enrollmentId
        self.reason = reason
        self.change = change
    }
}

extension EnrollmentChangeEvent: Equatable, Hashable {
    public static func == (lhs: EnrollmentChangeEvent, rhs: EnrollmentChangeEvent) -> Bool {
        if lhs.experimentSlug != rhs.experimentSlug {
            return false
        }
        if lhs.branchSlug != rhs.branchSlug {
            return false
        }
        if lhs.enrollmentId != rhs.enrollmentId {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.change != rhs.change {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(experimentSlug)
        hasher.combine(branchSlug)
        hasher.combine(enrollmentId)
        hasher.combine(reason)
        hasher.combine(change)
    }
}

private extension EnrollmentChangeEvent {
    static func read(from buf: Reader) throws -> EnrollmentChangeEvent {
        return try EnrollmentChangeEvent(
            experimentSlug: String.read(from: buf),
            branchSlug: String.read(from: buf),
            enrollmentId: String.read(from: buf),
            reason: String?.read(from: buf),
            change: EnrollmentChangeEventType.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        experimentSlug.write(into: buf)
        branchSlug.write(into: buf)
        enrollmentId.write(into: buf)
        reason.write(into: buf)
        change.write(into: buf)
    }
}

extension EnrollmentChangeEvent: ViaFfiUsingByteBuffer, ViaFfi {}

public protocol NimbusClientProtocol {
    func initialize() throws
    func getExperimentBranch(id: String) throws -> String?
    func getFeatureConfigVariables(featureId: String) throws -> String?
    func getExperimentBranches(experimentSlug: String) throws -> [ExperimentBranch]
    func getActiveExperiments() throws -> [EnrolledExperiment]
    func getAvailableExperiments() throws -> [AvailableExperiment]
    func getGlobalUserParticipation() throws -> Bool
    func setGlobalUserParticipation(optIn: Bool) throws -> [EnrollmentChangeEvent]
    func updateExperiments() throws -> [EnrollmentChangeEvent]
    func fetchExperiments() throws
    func applyPendingExperiments() throws -> [EnrollmentChangeEvent]
    func setExperimentsLocally(experimentsJson: String) throws
    func optInWithBranch(experimentSlug: String, branch: String) throws -> [EnrollmentChangeEvent]
    func optOut(experimentSlug: String) throws -> [EnrollmentChangeEvent]
    func resetTelemetryIdentifiers(newRandomizationUnits: AvailableRandomizationUnits) throws -> [EnrollmentChangeEvent]
}

public class NimbusClient: NimbusClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `ViaFfi` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(appCtx: AppContext, dbpath: String, remoteSettingsConfig: RemoteSettingsConfig?, availableRandomizationUnits: AvailableRandomizationUnits) throws {
        self.init(unsafeFromRawPointer: try

            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_new(appCtx.lower(), dbpath.lower(), remoteSettingsConfig.lower(), availableRandomizationUnits.lower(), $0)
            })
    }

    deinit {
        try! rustCall { ffi_nimbus_1c8c_NimbusClient_object_free(pointer, $0) }
    }

    public func initialize() throws {
        try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_initialize(self.pointer, $0)
            }
    }

    public func getExperimentBranch(id: String) throws -> String? {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_get_experiment_branch(self.pointer, id.lower(), $0)
            }
        return try String?.lift(_retval)
    }

    public func getFeatureConfigVariables(featureId: String) throws -> String? {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_get_feature_config_variables(self.pointer, featureId.lower(), $0)
            }
        return try String?.lift(_retval)
    }

    public func getExperimentBranches(experimentSlug: String) throws -> [ExperimentBranch] {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_get_experiment_branches(self.pointer, experimentSlug.lower(), $0)
            }
        return try [ExperimentBranch].lift(_retval)
    }

    public func getActiveExperiments() throws -> [EnrolledExperiment] {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_get_active_experiments(self.pointer, $0)
            }
        return try [EnrolledExperiment].lift(_retval)
    }

    public func getAvailableExperiments() throws -> [AvailableExperiment] {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_get_available_experiments(self.pointer, $0)
            }
        return try [AvailableExperiment].lift(_retval)
    }

    public func getGlobalUserParticipation() throws -> Bool {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_get_global_user_participation(self.pointer, $0)
            }
        return try Bool.lift(_retval)
    }

    public func setGlobalUserParticipation(optIn: Bool) throws -> [EnrollmentChangeEvent] {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_set_global_user_participation(self.pointer, optIn.lower(), $0)
            }
        return try [EnrollmentChangeEvent].lift(_retval)
    }

    public func updateExperiments() throws -> [EnrollmentChangeEvent] {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_update_experiments(self.pointer, $0)
            }
        return try [EnrollmentChangeEvent].lift(_retval)
    }

    public func fetchExperiments() throws {
        try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_fetch_experiments(self.pointer, $0)
            }
    }

    public func applyPendingExperiments() throws -> [EnrollmentChangeEvent] {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_apply_pending_experiments(self.pointer, $0)
            }
        return try [EnrollmentChangeEvent].lift(_retval)
    }

    public func setExperimentsLocally(experimentsJson: String) throws {
        try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_set_experiments_locally(self.pointer, experimentsJson.lower(), $0)
            }
    }

    public func optInWithBranch(experimentSlug: String, branch: String) throws -> [EnrollmentChangeEvent] {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_opt_in_with_branch(self.pointer, experimentSlug.lower(), branch.lower(), $0)
            }
        return try [EnrollmentChangeEvent].lift(_retval)
    }

    public func optOut(experimentSlug: String) throws -> [EnrollmentChangeEvent] {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_opt_out(self.pointer, experimentSlug.lower(), $0)
            }
        return try [EnrollmentChangeEvent].lift(_retval)
    }

    public func resetTelemetryIdentifiers(newRandomizationUnits: AvailableRandomizationUnits) throws -> [EnrollmentChangeEvent] {
        let _retval = try
            rustCallWithError(NimbusError.self) {
                nimbus_1c8c_NimbusClient_reset_telemetry_identifiers(self.pointer, newRandomizationUnits.lower(), $0)
            }
        return try [EnrollmentChangeEvent].lift(_retval)
    }
}

private extension NimbusClient {
    typealias FfiType = UnsafeMutableRawPointer

    static func read(from buf: Reader) throws -> Self {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    func write(into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower()))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Self {
        return Self(unsafeFromRawPointer: pointer)
    }

    func lower() -> UnsafeMutableRawPointer {
        return pointer
    }
}

// Ideally this would be `fileprivate`, but Swift says:
// """
// 'private' modifier cannot be used with extensions that declare protocol conformances
// """
extension NimbusClient: ViaFfi, Serializable {}
