// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(MozillaRustComponents)
    import MozillaRustComponents
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_places_de65_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_places_de65_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// A helper class to read values out of a byte buffer.
private class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset ..< offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        let _ = withUnsafeMutableBytes(of: &value) { data.copyBytes(to: $0, from: range) }
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads an arbitrary number of bytes, to be used to read
    // raw bytes, this is useful when lifting strings
    func readBytes(count: Int) throws -> [UInt8] {
        let range = offset ..< (offset + count)
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        var value = [UInt8](repeating: 0, count: count)
        value.withUnsafeMutableBufferPointer { buffer in
            data.copyBytes(to: buffer, from: range)
        }
        offset = range.upperBound
        return value
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
private class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        bytes = []
        offset = 0
    }

    func writeBytes<S>(_ byteArr: S) where S: Sequence, S.Element == UInt8 {
        bytes.append(contentsOf: byteArr)
    }

    // Writes an integer in big-endian order.
    //
    // Warning: make sure what you are trying to write
    // is in the correct type!
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        withUnsafeBytes(of: &value) { bytes.append(contentsOf: $0) }
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}

// Types conforming to `Serializable` can be read and written in a bytebuffer.
private protocol Serializable {
    func write(into: Writer)
    static func read(from: Reader) throws -> Self
}

// Types confirming to `ViaFfi` can be transferred back-and-for over the FFI.
// This is analogous to the Rust trait of the same name.
private protocol ViaFfi: Serializable {
    associatedtype FfiType
    static func lift(_ v: FfiType) throws -> Self
    func lower() -> FfiType
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol Primitive {}

private extension Primitive {
    typealias FfiType = Self

    static func lift(_ v: Self) throws -> Self {
        return v
    }

    func lower() -> Self {
        return self
    }
}

// Types conforming to `ViaFfiUsingByteBuffer` lift and lower into a bytebuffer.
// Use this for complex types where it's hard to write a custom lift/lower.
private protocol ViaFfiUsingByteBuffer: Serializable {}

private extension ViaFfiUsingByteBuffer {
    typealias FfiType = RustBuffer

    static func lift(_ buf: FfiType) throws -> Self {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try Self.read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    func lower() -> FfiType {
        let writer = Writer()
        write(into: writer)
        return RustBuffer(bytes: writer.bytes)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, E: ViaFfiUsingByteBuffer & Error>(_: E.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: { try E.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw UniffiInternalError.rustPanic(try String.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Protocols for converters we'll implement in templates

private protocol FfiConverter {
    associatedtype SwiftType
    associatedtype FfiType

    static func lift(_ ffiValue: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType

    static func read(from: Reader) throws -> SwiftType
    static func write(_ value: SwiftType, into: Writer)
}

private protocol FfiConverterUsingByteBuffer: FfiConverter where FfiType == RustBuffer {
    // Empty, because we want to declare some helper methods in the extension below.
}

extension FfiConverterUsingByteBuffer {
    static func lower(_ value: SwiftType) -> FfiType {
        let writer = Writer()
        Self.write(value, into: writer)
        return RustBuffer(bytes: writer.bytes)
    }

    static func lift(_ buf: FfiType) throws -> SwiftType {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try Self.read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }
}

// Helpers for structural types. Note that because of canonical_names, it /should/ be impossible
// to make another `FfiConverterSequence` etc just using the UDL.
private enum FfiConverterSequence {
    static func write<T>(_ value: [T], into buf: Writer, writeItem: (T, Writer) -> Void) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            writeItem(item, buf)
        }
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> T) throws -> [T] {
        let len: Int32 = try buf.readInt()
        var seq = [T]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try readItem(buf))
        }
        return seq
    }
}

private enum FfiConverterOptional {
    static func write<T>(_ value: T?, into buf: Writer, writeItem: (T, Writer) -> Void) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        writeItem(value, buf)
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> T) throws -> T? {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try readItem(buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private enum FfiConverterDictionary {
    static func write<T>(_ value: [String: T], into buf: Writer, writeItem: (String, T, Writer) -> Void) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            writeItem(key, value, buf)
        }
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> (String, T)) throws -> [String: T] {
        let len: Int32 = try buf.readInt()
        var dict = [String: T]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let (key, value) = try readItem(buf)
            dict[key] = value
        }
        return dict
    }
}

// Public interface members begin here.

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ConnectionType {
    case readOnly
    case readWrite
    case sync
}

extension ConnectionType: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> ConnectionType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .readOnly
        case 2: return .readWrite
        case 3: return .sync
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .readOnly:
            buf.writeInt(Int32(1))

        case .readWrite:
            buf.writeInt(Int32(2))

        case .sync:
            buf.writeInt(Int32(3))
        }
    }
}

extension ConnectionType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FrecencyThresholdOption {
    case none
    case skipOneTimePages
}

extension FrecencyThresholdOption: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> FrecencyThresholdOption {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .none
        case 2: return .skipOneTimePages
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .none:
            buf.writeInt(Int32(1))

        case .skipOneTimePages:
            buf.writeInt(Int32(2))
        }
    }
}

extension FrecencyThresholdOption: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MatchReason {
    case keyword
    case origin
    case urlMatch
    case previousUse
    case bookmark
    case tags
}

extension MatchReason: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> MatchReason {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .keyword
        case 2: return .origin
        case 3: return .urlMatch
        case 4: return .previousUse
        case 5: return .bookmark
        case 6: return .tags
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .keyword:
            buf.writeInt(Int32(1))

        case .origin:
            buf.writeInt(Int32(2))

        case .urlMatch:
            buf.writeInt(Int32(3))

        case .previousUse:
            buf.writeInt(Int32(4))

        case .bookmark:
            buf.writeInt(Int32(5))

        case .tags:
            buf.writeInt(Int32(6))
        }
    }
}

extension MatchReason: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DocumentType {
    case regular
    case media
}

extension DocumentType: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> DocumentType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .regular
        case 2: return .media
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .regular:
            buf.writeInt(Int32(1))

        case .media:
            buf.writeInt(Int32(2))
        }
    }
}

extension DocumentType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VisitTransition {
    case link
    case typed
    case bookmark
    case embed
    case redirectPermanent
    case redirectTemporary
    case download
    case framedLink
    case reload
}

extension VisitTransition: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> VisitTransition {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .link
        case 2: return .typed
        case 3: return .bookmark
        case 4: return .embed
        case 5: return .redirectPermanent
        case 6: return .redirectTemporary
        case 7: return .download
        case 8: return .framedLink
        case 9: return .reload
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .link:
            buf.writeInt(Int32(1))

        case .typed:
            buf.writeInt(Int32(2))

        case .bookmark:
            buf.writeInt(Int32(3))

        case .embed:
            buf.writeInt(Int32(4))

        case .redirectPermanent:
            buf.writeInt(Int32(5))

        case .redirectTemporary:
            buf.writeInt(Int32(6))

        case .download:
            buf.writeInt(Int32(7))

        case .framedLink:
            buf.writeInt(Int32(8))

        case .reload:
            buf.writeInt(Int32(9))
        }
    }
}

extension VisitTransition: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BookmarkItem {
    case bookmark(b: BookmarkData)
    case separator(s: BookmarkSeparator)
    case folder(f: BookmarkFolder)
}

extension BookmarkItem: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> BookmarkItem {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .bookmark(
                b: try BookmarkData.read(from: buf)
            )
        case 2: return .separator(
                s: try BookmarkSeparator.read(from: buf)
            )
        case 3: return .folder(
                f: try BookmarkFolder.read(from: buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .bookmark(b):
            buf.writeInt(Int32(1))
            b.write(into: buf)

        case let .separator(s):
            buf.writeInt(Int32(2))
            s.write(into: buf)

        case let .folder(f):
            buf.writeInt(Int32(3))
            f.write(into: buf)
        }
    }
}

extension BookmarkItem: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BookmarkPosition {
    case specific(pos: UInt32)
    case append
}

extension BookmarkPosition: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> BookmarkPosition {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .specific(
                pos: try UInt32.read(from: buf)
            )
        case 2: return .append
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .specific(pos):
            buf.writeInt(Int32(1))
            pos.write(into: buf)

        case .append:
            buf.writeInt(Int32(2))
        }
    }
}

extension BookmarkPosition: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum InsertableBookmarkItem {
    case bookmark(b: InsertableBookmark)
    case folder(f: InsertableBookmarkFolder)
    case separator(s: InsertableBookmarkSeparator)
}

extension InsertableBookmarkItem: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> InsertableBookmarkItem {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .bookmark(
                b: try InsertableBookmark.read(from: buf)
            )
        case 2: return .folder(
                f: try InsertableBookmarkFolder.read(from: buf)
            )
        case 3: return .separator(
                s: try InsertableBookmarkSeparator.read(from: buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .bookmark(b):
            buf.writeInt(Int32(1))
            b.write(into: buf)

        case let .folder(f):
            buf.writeInt(Int32(2))
            f.write(into: buf)

        case let .separator(s):
            buf.writeInt(Int32(3))
            s.write(into: buf)
        }
    }
}

extension InsertableBookmarkItem: Equatable, Hashable {}

public func placesApiNew(dbPath: String) throws -> PlacesApi {
    let _retval = try

        rustCallWithError(PlacesError.self) {
            places_de65_places_api_new(dbPath.lower(), $0)
        }
    return try PlacesApi.lift(_retval)
}

public protocol SqlInterruptHandleProtocol {
    func interrupt()
}

public class SqlInterruptHandle: SqlInterruptHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `ViaFfi` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_places_de65_SqlInterruptHandle_object_free(pointer, $0) }
    }

    public func interrupt() {
        try!
            rustCall {
                places_de65_SqlInterruptHandle_interrupt(self.pointer, $0)
            }
    }
}

private extension SqlInterruptHandle {
    typealias FfiType = UnsafeMutableRawPointer

    static func read(from buf: Reader) throws -> Self {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    func write(into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower()))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Self {
        return Self(unsafeFromRawPointer: pointer)
    }

    func lower() -> UnsafeMutableRawPointer {
        return pointer
    }
}

// Ideally this would be `fileprivate`, but Swift says:
// """
// 'private' modifier cannot be used with extensions that declare protocol conformances
// """
extension SqlInterruptHandle: ViaFfi, Serializable {}

public protocol PlacesApiProtocol {
    func newConnection(connType: ConnectionType) throws -> PlacesConnection
    func newSyncConnInterruptHandle() throws -> SqlInterruptHandle
    func registerWithSyncManager()
    func resetHistory() throws
    func historySync(keyId: String, accessToken: String, syncKey: String, tokenserverUrl: String) throws -> String
    func bookmarksSync(keyId: String, accessToken: String, syncKey: String, tokenserverUrl: String) throws -> String
    func placesPinnedSitesImportFromFennec(dbPath: String) throws -> [BookmarkItem]
    func placesHistoryImportFromFennec(dbPath: String) throws -> String
    func placesBookmarksImportFromFennec(dbPath: String) throws -> String
    func placesBookmarksImportFromIos(dbPath: String) throws
    func bookmarksReset() throws
}

public class PlacesApi: PlacesApiProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `ViaFfi` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_places_de65_PlacesApi_object_free(pointer, $0) }
    }

    public func newConnection(connType: ConnectionType) throws -> PlacesConnection {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesApi_new_connection(self.pointer, connType.lower(), $0)
            }
        return try PlacesConnection.lift(_retval)
    }

    public func newSyncConnInterruptHandle() throws -> SqlInterruptHandle {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesApi_new_sync_conn_interrupt_handle(self.pointer, $0)
            }
        return try SqlInterruptHandle.lift(_retval)
    }

    public func registerWithSyncManager() {
        try!
            rustCall {
                places_de65_PlacesApi_register_with_sync_manager(self.pointer, $0)
            }
    }

    public func resetHistory() throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesApi_reset_history(self.pointer, $0)
            }
    }

    public func historySync(keyId: String, accessToken: String, syncKey: String, tokenserverUrl: String) throws -> String {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesApi_history_sync(self.pointer, keyId.lower(), accessToken.lower(), syncKey.lower(), FfiConverterTypeUrl.lower(tokenserverUrl), $0)
            }
        return try String.lift(_retval)
    }

    public func bookmarksSync(keyId: String, accessToken: String, syncKey: String, tokenserverUrl: String) throws -> String {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesApi_bookmarks_sync(self.pointer, keyId.lower(), accessToken.lower(), syncKey.lower(), FfiConverterTypeUrl.lower(tokenserverUrl), $0)
            }
        return try String.lift(_retval)
    }

    public func placesPinnedSitesImportFromFennec(dbPath: String) throws -> [BookmarkItem] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesApi_places_pinned_sites_import_from_fennec(self.pointer, dbPath.lower(), $0)
            }
        return try FfiConverterSequenceEnumBookmarkItem.lift(_retval)
    }

    public func placesHistoryImportFromFennec(dbPath: String) throws -> String {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesApi_places_history_import_from_fennec(self.pointer, dbPath.lower(), $0)
            }
        return try String.lift(_retval)
    }

    public func placesBookmarksImportFromFennec(dbPath: String) throws -> String {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesApi_places_bookmarks_import_from_fennec(self.pointer, dbPath.lower(), $0)
            }
        return try String.lift(_retval)
    }

    public func placesBookmarksImportFromIos(dbPath: String) throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesApi_places_bookmarks_import_from_ios(self.pointer, dbPath.lower(), $0)
            }
    }

    public func bookmarksReset() throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesApi_bookmarks_reset(self.pointer, $0)
            }
    }
}

private extension PlacesApi {
    typealias FfiType = UnsafeMutableRawPointer

    static func read(from buf: Reader) throws -> Self {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    func write(into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower()))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Self {
        return Self(unsafeFromRawPointer: pointer)
    }

    func lower() -> UnsafeMutableRawPointer {
        return pointer
    }
}

// Ideally this would be `fileprivate`, but Swift says:
// """
// 'private' modifier cannot be used with extensions that declare protocol conformances
// """
extension PlacesApi: ViaFfi, Serializable {}

public protocol PlacesConnectionProtocol {
    func newInterruptHandle() throws -> SqlInterruptHandle
    func getLatestHistoryMetadataForUrl(url: String) throws -> HistoryMetadata?
    func getHistoryMetadataBetween(start: Int64, end: Int64) throws -> [HistoryMetadata]
    func getHistoryMetadataSince(since: Int64) throws -> [HistoryMetadata]
    func queryAutocomplete(search: String, limit: Int32) throws -> [SearchResult]
    func acceptResult(searchString: String, url: String) throws
    func matchUrl(query: String) throws -> String?
    func queryHistoryMetadata(query: String, limit: Int32) throws -> [HistoryMetadata]
    func getHistoryHighlights(weights: HistoryHighlightWeights, limit: Int32) throws -> [HistoryHighlight]
    func noteHistoryMetadataObservation(data: HistoryMetadataObservation) throws
    func metadataDelete(url: String, referrerUrl: String?, searchTerm: String?) throws
    func metadataDeleteOlderThan(olderThan: Int64) throws
    func applyObservation(visit: VisitObservation) throws
    func getVisitedUrlsInRange(start: Int64, end: Int64, includeRemote: Bool) throws -> [String]
    func getVisitInfos(startDate: Int64, endDate: Int64, excludeTypes: Int32) throws -> [HistoryVisitInfo]
    func getVisitCount(excludeTypes: Int32) throws -> Int64
    func getVisitPage(offset: Int64, count: Int64, excludeTypes: Int32) throws -> [HistoryVisitInfo]
    func getVisitPageWithBound(bound: Int64, offset: Int64, count: Int64, excludeTypes: Int32) throws -> HistoryVisitInfosWithBound
    func getVisited(urls: [String]) throws -> [Bool]
    func deleteVisitsFor(url: String) throws
    func deleteVisitsBetween(start: Int64, end: Int64) throws
    func deleteVisit(url: String, timestamp: Int64) throws
    func getTopFrecentSiteInfos(numItems: Int32, thresholdOption: FrecencyThresholdOption) throws -> [TopFrecentSiteInfo]
    func wipeLocalHistory() throws
    func deleteEverythingHistory() throws
    func pruneDestructively() throws
    func runMaintenance() throws
    func bookmarksGetTree(itemGuid: String) throws -> BookmarkItem?
    func bookmarksGetByGuid(guid: String, getDirectChildren: Bool) throws -> BookmarkItem?
    func bookmarksGetAllWithUrl(url: String) throws -> [BookmarkItem]
    func bookmarksSearch(query: String, limit: Int32) throws -> [BookmarkItem]
    func bookmarksGetRecent(limit: Int32) throws -> [BookmarkItem]
    func bookmarksDelete(id: String) throws -> Bool
    func bookmarksDeleteEverything() throws
    func bookmarksGetUrlForKeyword(keyword: String) throws -> String?
    func bookmarksUpdate(data: BookmarkUpdateInfo) throws
    func bookmarksInsert(bookmark: InsertableBookmarkItem) throws -> String
}

public class PlacesConnection: PlacesConnectionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `ViaFfi` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_places_de65_PlacesConnection_object_free(pointer, $0) }
    }

    public func newInterruptHandle() throws -> SqlInterruptHandle {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_new_interrupt_handle(self.pointer, $0)
            }
        return try SqlInterruptHandle.lift(_retval)
    }

    public func getLatestHistoryMetadataForUrl(url: String) throws -> HistoryMetadata? {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_get_latest_history_metadata_for_url(self.pointer, FfiConverterTypeUrl.lower(url), $0)
            }
        return try FfiConverterOptionRecordHistoryMetadata.lift(_retval)
    }

    public func getHistoryMetadataBetween(start: Int64, end: Int64) throws -> [HistoryMetadata] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_get_history_metadata_between(self.pointer, FfiConverterTypeTimestamp.lower(start), FfiConverterTypeTimestamp.lower(end), $0)
            }
        return try FfiConverterSequenceRecordHistoryMetadata.lift(_retval)
    }

    public func getHistoryMetadataSince(since: Int64) throws -> [HistoryMetadata] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_get_history_metadata_since(self.pointer, FfiConverterTypeTimestamp.lower(since), $0)
            }
        return try FfiConverterSequenceRecordHistoryMetadata.lift(_retval)
    }

    public func queryAutocomplete(search: String, limit: Int32) throws -> [SearchResult] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_query_autocomplete(self.pointer, search.lower(), limit.lower(), $0)
            }
        return try FfiConverterSequenceRecordSearchResult.lift(_retval)
    }

    public func acceptResult(searchString: String, url: String) throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_accept_result(self.pointer, searchString.lower(), url.lower(), $0)
            }
    }

    public func matchUrl(query: String) throws -> String? {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_match_url(self.pointer, query.lower(), $0)
            }
        return try FfiConverterOptionUrl.lift(_retval)
    }

    public func queryHistoryMetadata(query: String, limit: Int32) throws -> [HistoryMetadata] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_query_history_metadata(self.pointer, query.lower(), limit.lower(), $0)
            }
        return try FfiConverterSequenceRecordHistoryMetadata.lift(_retval)
    }

    public func getHistoryHighlights(weights: HistoryHighlightWeights, limit: Int32) throws -> [HistoryHighlight] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_get_history_highlights(self.pointer, weights.lower(), limit.lower(), $0)
            }
        return try FfiConverterSequenceRecordHistoryHighlight.lift(_retval)
    }

    public func noteHistoryMetadataObservation(data: HistoryMetadataObservation) throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_note_history_metadata_observation(self.pointer, data.lower(), $0)
            }
    }

    public func metadataDelete(url: String, referrerUrl: String?, searchTerm: String?) throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_metadata_delete(self.pointer, FfiConverterTypeUrl.lower(url), FfiConverterOptionUrl.lower(referrerUrl), FfiConverterOptionString.lower(searchTerm), $0)
            }
    }

    public func metadataDeleteOlderThan(olderThan: Int64) throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_metadata_delete_older_than(self.pointer, FfiConverterTypeTimestamp.lower(olderThan), $0)
            }
    }

    public func applyObservation(visit: VisitObservation) throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_apply_observation(self.pointer, visit.lower(), $0)
            }
    }

    public func getVisitedUrlsInRange(start: Int64, end: Int64, includeRemote: Bool) throws -> [String] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_get_visited_urls_in_range(self.pointer, FfiConverterTypeTimestamp.lower(start), FfiConverterTypeTimestamp.lower(end), includeRemote.lower(), $0)
            }
        return try FfiConverterSequenceUrl.lift(_retval)
    }

    public func getVisitInfos(startDate: Int64, endDate: Int64, excludeTypes: Int32) throws -> [HistoryVisitInfo] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_get_visit_infos(self.pointer, FfiConverterTypeTimestamp.lower(startDate), FfiConverterTypeTimestamp.lower(endDate), FfiConverterTypeVisitTransitionSet.lower(excludeTypes), $0)
            }
        return try FfiConverterSequenceRecordHistoryVisitInfo.lift(_retval)
    }

    public func getVisitCount(excludeTypes: Int32) throws -> Int64 {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_get_visit_count(self.pointer, FfiConverterTypeVisitTransitionSet.lower(excludeTypes), $0)
            }
        return try Int64.lift(_retval)
    }

    public func getVisitPage(offset: Int64, count: Int64, excludeTypes: Int32) throws -> [HistoryVisitInfo] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_get_visit_page(self.pointer, offset.lower(), count.lower(), FfiConverterTypeVisitTransitionSet.lower(excludeTypes), $0)
            }
        return try FfiConverterSequenceRecordHistoryVisitInfo.lift(_retval)
    }

    public func getVisitPageWithBound(bound: Int64, offset: Int64, count: Int64, excludeTypes: Int32) throws -> HistoryVisitInfosWithBound {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_get_visit_page_with_bound(self.pointer, bound.lower(), offset.lower(), count.lower(), FfiConverterTypeVisitTransitionSet.lower(excludeTypes), $0)
            }
        return try HistoryVisitInfosWithBound.lift(_retval)
    }

    public func getVisited(urls: [String]) throws -> [Bool] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_get_visited(self.pointer, FfiConverterSequenceString.lower(urls), $0)
            }
        return try FfiConverterSequenceBool.lift(_retval)
    }

    public func deleteVisitsFor(url: String) throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_delete_visits_for(self.pointer, url.lower(), $0)
            }
    }

    public func deleteVisitsBetween(start: Int64, end: Int64) throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_delete_visits_between(self.pointer, FfiConverterTypeTimestamp.lower(start), FfiConverterTypeTimestamp.lower(end), $0)
            }
    }

    public func deleteVisit(url: String, timestamp: Int64) throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_delete_visit(self.pointer, url.lower(), FfiConverterTypeTimestamp.lower(timestamp), $0)
            }
    }

    public func getTopFrecentSiteInfos(numItems: Int32, thresholdOption: FrecencyThresholdOption) throws -> [TopFrecentSiteInfo] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_get_top_frecent_site_infos(self.pointer, numItems.lower(), thresholdOption.lower(), $0)
            }
        return try FfiConverterSequenceRecordTopFrecentSiteInfo.lift(_retval)
    }

    public func wipeLocalHistory() throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_wipe_local_history(self.pointer, $0)
            }
    }

    public func deleteEverythingHistory() throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_delete_everything_history(self.pointer, $0)
            }
    }

    public func pruneDestructively() throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_prune_destructively(self.pointer, $0)
            }
    }

    public func runMaintenance() throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_run_maintenance(self.pointer, $0)
            }
    }

    public func bookmarksGetTree(itemGuid: String) throws -> BookmarkItem? {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_bookmarks_get_tree(self.pointer, FfiConverterTypeGuid.lower(itemGuid), $0)
            }
        return try FfiConverterOptionEnumBookmarkItem.lift(_retval)
    }

    public func bookmarksGetByGuid(guid: String, getDirectChildren: Bool) throws -> BookmarkItem? {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_bookmarks_get_by_guid(self.pointer, FfiConverterTypeGuid.lower(guid), getDirectChildren.lower(), $0)
            }
        return try FfiConverterOptionEnumBookmarkItem.lift(_retval)
    }

    public func bookmarksGetAllWithUrl(url: String) throws -> [BookmarkItem] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_bookmarks_get_all_with_url(self.pointer, url.lower(), $0)
            }
        return try FfiConverterSequenceEnumBookmarkItem.lift(_retval)
    }

    public func bookmarksSearch(query: String, limit: Int32) throws -> [BookmarkItem] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_bookmarks_search(self.pointer, query.lower(), limit.lower(), $0)
            }
        return try FfiConverterSequenceEnumBookmarkItem.lift(_retval)
    }

    public func bookmarksGetRecent(limit: Int32) throws -> [BookmarkItem] {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_bookmarks_get_recent(self.pointer, limit.lower(), $0)
            }
        return try FfiConverterSequenceEnumBookmarkItem.lift(_retval)
    }

    public func bookmarksDelete(id: String) throws -> Bool {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_bookmarks_delete(self.pointer, FfiConverterTypeGuid.lower(id), $0)
            }
        return try Bool.lift(_retval)
    }

    public func bookmarksDeleteEverything() throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_bookmarks_delete_everything(self.pointer, $0)
            }
    }

    public func bookmarksGetUrlForKeyword(keyword: String) throws -> String? {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_bookmarks_get_url_for_keyword(self.pointer, keyword.lower(), $0)
            }
        return try FfiConverterOptionUrl.lift(_retval)
    }

    public func bookmarksUpdate(data: BookmarkUpdateInfo) throws {
        try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_bookmarks_update(self.pointer, data.lower(), $0)
            }
    }

    public func bookmarksInsert(bookmark: InsertableBookmarkItem) throws -> String {
        let _retval = try
            rustCallWithError(PlacesError.self) {
                places_de65_PlacesConnection_bookmarks_insert(self.pointer, bookmark.lower(), $0)
            }
        return try FfiConverterTypeGuid.lift(_retval)
    }
}

private extension PlacesConnection {
    typealias FfiType = UnsafeMutableRawPointer

    static func read(from buf: Reader) throws -> Self {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    func write(into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower()))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Self {
        return Self(unsafeFromRawPointer: pointer)
    }

    func lower() -> UnsafeMutableRawPointer {
        return pointer
    }
}

// Ideally this would be `fileprivate`, but Swift says:
// """
// 'private' modifier cannot be used with extensions that declare protocol conformances
// """
extension PlacesConnection: ViaFfi, Serializable {}

public struct SearchResult {
    public var url: String
    public var title: String
    public var frecency: Int64
    public var reasons: [MatchReason]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, title: String, frecency: Int64, reasons: [MatchReason]) {
        self.url = url
        self.title = title
        self.frecency = frecency
        self.reasons = reasons
    }
}

extension SearchResult: Equatable, Hashable {
    public static func == (lhs: SearchResult, rhs: SearchResult) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.frecency != rhs.frecency {
            return false
        }
        if lhs.reasons != rhs.reasons {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(title)
        hasher.combine(frecency)
        hasher.combine(reasons)
    }
}

private extension SearchResult {
    static func read(from buf: Reader) throws -> SearchResult {
        return try SearchResult(
            url: FfiConverterTypeUrl.read(buf),
            title: String.read(from: buf),
            frecency: Int64.read(from: buf),
            reasons: FfiConverterSequenceEnumMatchReason.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterTypeUrl.write(url, buf)
        title.write(into: buf)
        frecency.write(into: buf)
        FfiConverterSequenceEnumMatchReason.write(reasons, into: buf)
    }
}

extension SearchResult: ViaFfiUsingByteBuffer, ViaFfi {}

public struct HistoryMetadataObservation {
    public var url: String
    public var referrerUrl: String?
    public var searchTerm: String?
    public var viewTime: Int32?
    public var documentType: DocumentType?
    public var title: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, referrerUrl: String? = nil, searchTerm: String? = nil, viewTime: Int32? = nil, documentType: DocumentType? = nil, title: String? = nil) {
        self.url = url
        self.referrerUrl = referrerUrl
        self.searchTerm = searchTerm
        self.viewTime = viewTime
        self.documentType = documentType
        self.title = title
    }
}

extension HistoryMetadataObservation: Equatable, Hashable {
    public static func == (lhs: HistoryMetadataObservation, rhs: HistoryMetadataObservation) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.referrerUrl != rhs.referrerUrl {
            return false
        }
        if lhs.searchTerm != rhs.searchTerm {
            return false
        }
        if lhs.viewTime != rhs.viewTime {
            return false
        }
        if lhs.documentType != rhs.documentType {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(referrerUrl)
        hasher.combine(searchTerm)
        hasher.combine(viewTime)
        hasher.combine(documentType)
        hasher.combine(title)
    }
}

private extension HistoryMetadataObservation {
    static func read(from buf: Reader) throws -> HistoryMetadataObservation {
        return try HistoryMetadataObservation(
            url: String.read(from: buf),
            referrerUrl: FfiConverterOptionString.read(from: buf),
            searchTerm: FfiConverterOptionString.read(from: buf),
            viewTime: FfiConverterOptionInt32.read(from: buf),
            documentType: FfiConverterOptionEnumDocumentType.read(from: buf),
            title: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        url.write(into: buf)
        FfiConverterOptionString.write(referrerUrl, into: buf)
        FfiConverterOptionString.write(searchTerm, into: buf)
        FfiConverterOptionInt32.write(viewTime, into: buf)
        FfiConverterOptionEnumDocumentType.write(documentType, into: buf)
        FfiConverterOptionString.write(title, into: buf)
    }
}

extension HistoryMetadataObservation: ViaFfiUsingByteBuffer, ViaFfi {}

public struct HistoryMetadata {
    public var url: String
    public var title: String?
    public var previewImageUrl: String?
    public var createdAt: Int64
    public var updatedAt: Int64
    public var totalViewTime: Int32
    public var searchTerm: String?
    public var documentType: DocumentType
    public var referrerUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, title: String?, previewImageUrl: String?, createdAt: Int64, updatedAt: Int64, totalViewTime: Int32, searchTerm: String?, documentType: DocumentType, referrerUrl: String?) {
        self.url = url
        self.title = title
        self.previewImageUrl = previewImageUrl
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.totalViewTime = totalViewTime
        self.searchTerm = searchTerm
        self.documentType = documentType
        self.referrerUrl = referrerUrl
    }
}

extension HistoryMetadata: Equatable, Hashable {
    public static func == (lhs: HistoryMetadata, rhs: HistoryMetadata) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.previewImageUrl != rhs.previewImageUrl {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.totalViewTime != rhs.totalViewTime {
            return false
        }
        if lhs.searchTerm != rhs.searchTerm {
            return false
        }
        if lhs.documentType != rhs.documentType {
            return false
        }
        if lhs.referrerUrl != rhs.referrerUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(title)
        hasher.combine(previewImageUrl)
        hasher.combine(createdAt)
        hasher.combine(updatedAt)
        hasher.combine(totalViewTime)
        hasher.combine(searchTerm)
        hasher.combine(documentType)
        hasher.combine(referrerUrl)
    }
}

private extension HistoryMetadata {
    static func read(from buf: Reader) throws -> HistoryMetadata {
        return try HistoryMetadata(
            url: String.read(from: buf),
            title: FfiConverterOptionString.read(from: buf),
            previewImageUrl: FfiConverterOptionString.read(from: buf),
            createdAt: Int64.read(from: buf),
            updatedAt: Int64.read(from: buf),
            totalViewTime: Int32.read(from: buf),
            searchTerm: FfiConverterOptionString.read(from: buf),
            documentType: DocumentType.read(from: buf),
            referrerUrl: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        url.write(into: buf)
        FfiConverterOptionString.write(title, into: buf)
        FfiConverterOptionString.write(previewImageUrl, into: buf)
        createdAt.write(into: buf)
        updatedAt.write(into: buf)
        totalViewTime.write(into: buf)
        FfiConverterOptionString.write(searchTerm, into: buf)
        documentType.write(into: buf)
        FfiConverterOptionString.write(referrerUrl, into: buf)
    }
}

extension HistoryMetadata: ViaFfiUsingByteBuffer, ViaFfi {}

public struct HistoryHighlightWeights {
    public var viewTime: Double
    public var frequency: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(viewTime: Double, frequency: Double) {
        self.viewTime = viewTime
        self.frequency = frequency
    }
}

extension HistoryHighlightWeights: Equatable, Hashable {
    public static func == (lhs: HistoryHighlightWeights, rhs: HistoryHighlightWeights) -> Bool {
        if lhs.viewTime != rhs.viewTime {
            return false
        }
        if lhs.frequency != rhs.frequency {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(viewTime)
        hasher.combine(frequency)
    }
}

private extension HistoryHighlightWeights {
    static func read(from buf: Reader) throws -> HistoryHighlightWeights {
        return try HistoryHighlightWeights(
            viewTime: Double.read(from: buf),
            frequency: Double.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        viewTime.write(into: buf)
        frequency.write(into: buf)
    }
}

extension HistoryHighlightWeights: ViaFfiUsingByteBuffer, ViaFfi {}

public struct HistoryHighlight {
    public var score: Double
    public var placeId: Int32
    public var url: String
    public var title: String?
    public var previewImageUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(score: Double, placeId: Int32, url: String, title: String?, previewImageUrl: String?) {
        self.score = score
        self.placeId = placeId
        self.url = url
        self.title = title
        self.previewImageUrl = previewImageUrl
    }
}

extension HistoryHighlight: Equatable, Hashable {
    public static func == (lhs: HistoryHighlight, rhs: HistoryHighlight) -> Bool {
        if lhs.score != rhs.score {
            return false
        }
        if lhs.placeId != rhs.placeId {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.previewImageUrl != rhs.previewImageUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(score)
        hasher.combine(placeId)
        hasher.combine(url)
        hasher.combine(title)
        hasher.combine(previewImageUrl)
    }
}

private extension HistoryHighlight {
    static func read(from buf: Reader) throws -> HistoryHighlight {
        return try HistoryHighlight(
            score: Double.read(from: buf),
            placeId: Int32.read(from: buf),
            url: String.read(from: buf),
            title: FfiConverterOptionString.read(from: buf),
            previewImageUrl: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        score.write(into: buf)
        placeId.write(into: buf)
        url.write(into: buf)
        FfiConverterOptionString.write(title, into: buf)
        FfiConverterOptionString.write(previewImageUrl, into: buf)
    }
}

extension HistoryHighlight: ViaFfiUsingByteBuffer, ViaFfi {}

public struct HistoryVisitInfo {
    public var url: String
    public var title: String?
    public var timestamp: Int64
    public var visitType: VisitTransition
    public var isHidden: Bool
    public var previewImageUrl: String?
    public var isRemote: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, title: String?, timestamp: Int64, visitType: VisitTransition, isHidden: Bool, previewImageUrl: String?, isRemote: Bool) {
        self.url = url
        self.title = title
        self.timestamp = timestamp
        self.visitType = visitType
        self.isHidden = isHidden
        self.previewImageUrl = previewImageUrl
        self.isRemote = isRemote
    }
}

extension HistoryVisitInfo: Equatable, Hashable {
    public static func == (lhs: HistoryVisitInfo, rhs: HistoryVisitInfo) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.visitType != rhs.visitType {
            return false
        }
        if lhs.isHidden != rhs.isHidden {
            return false
        }
        if lhs.previewImageUrl != rhs.previewImageUrl {
            return false
        }
        if lhs.isRemote != rhs.isRemote {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(title)
        hasher.combine(timestamp)
        hasher.combine(visitType)
        hasher.combine(isHidden)
        hasher.combine(previewImageUrl)
        hasher.combine(isRemote)
    }
}

private extension HistoryVisitInfo {
    static func read(from buf: Reader) throws -> HistoryVisitInfo {
        return try HistoryVisitInfo(
            url: FfiConverterTypeUrl.read(buf),
            title: FfiConverterOptionString.read(from: buf),
            timestamp: FfiConverterTypeTimestamp.read(buf),
            visitType: VisitTransition.read(from: buf),
            isHidden: Bool.read(from: buf),
            previewImageUrl: FfiConverterOptionUrl.read(from: buf),
            isRemote: Bool.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterTypeUrl.write(url, buf)
        FfiConverterOptionString.write(title, into: buf)
        FfiConverterTypeTimestamp.write(timestamp, buf)
        visitType.write(into: buf)
        isHidden.write(into: buf)
        FfiConverterOptionUrl.write(previewImageUrl, into: buf)
        isRemote.write(into: buf)
    }
}

extension HistoryVisitInfo: ViaFfiUsingByteBuffer, ViaFfi {}

public struct HistoryVisitInfosWithBound {
    public var infos: [HistoryVisitInfo]
    public var bound: Int64
    public var offset: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(infos: [HistoryVisitInfo], bound: Int64, offset: Int64) {
        self.infos = infos
        self.bound = bound
        self.offset = offset
    }
}

extension HistoryVisitInfosWithBound: Equatable, Hashable {
    public static func == (lhs: HistoryVisitInfosWithBound, rhs: HistoryVisitInfosWithBound) -> Bool {
        if lhs.infos != rhs.infos {
            return false
        }
        if lhs.bound != rhs.bound {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(infos)
        hasher.combine(bound)
        hasher.combine(offset)
    }
}

private extension HistoryVisitInfosWithBound {
    static func read(from buf: Reader) throws -> HistoryVisitInfosWithBound {
        return try HistoryVisitInfosWithBound(
            infos: FfiConverterSequenceRecordHistoryVisitInfo.read(from: buf),
            bound: Int64.read(from: buf),
            offset: Int64.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceRecordHistoryVisitInfo.write(infos, into: buf)
        bound.write(into: buf)
        offset.write(into: buf)
    }
}

extension HistoryVisitInfosWithBound: ViaFfiUsingByteBuffer, ViaFfi {}

public struct VisitObservation {
    public var url: String
    public var title: String?
    public var visitType: VisitTransition?
    public var isError: Bool?
    public var isRedirectSource: Bool?
    public var isPermanentRedirectSource: Bool?
    public var at: Int64?
    public var referrer: String?
    public var isRemote: Bool?
    public var previewImageUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, title: String? = nil, visitType: VisitTransition?, isError: Bool? = nil, isRedirectSource: Bool? = nil, isPermanentRedirectSource: Bool? = nil, at: Int64? = nil, referrer: String? = nil, isRemote: Bool? = nil, previewImageUrl: String? = nil) {
        self.url = url
        self.title = title
        self.visitType = visitType
        self.isError = isError
        self.isRedirectSource = isRedirectSource
        self.isPermanentRedirectSource = isPermanentRedirectSource
        self.at = at
        self.referrer = referrer
        self.isRemote = isRemote
        self.previewImageUrl = previewImageUrl
    }
}

extension VisitObservation: Equatable, Hashable {
    public static func == (lhs: VisitObservation, rhs: VisitObservation) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.visitType != rhs.visitType {
            return false
        }
        if lhs.isError != rhs.isError {
            return false
        }
        if lhs.isRedirectSource != rhs.isRedirectSource {
            return false
        }
        if lhs.isPermanentRedirectSource != rhs.isPermanentRedirectSource {
            return false
        }
        if lhs.at != rhs.at {
            return false
        }
        if lhs.referrer != rhs.referrer {
            return false
        }
        if lhs.isRemote != rhs.isRemote {
            return false
        }
        if lhs.previewImageUrl != rhs.previewImageUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(title)
        hasher.combine(visitType)
        hasher.combine(isError)
        hasher.combine(isRedirectSource)
        hasher.combine(isPermanentRedirectSource)
        hasher.combine(at)
        hasher.combine(referrer)
        hasher.combine(isRemote)
        hasher.combine(previewImageUrl)
    }
}

private extension VisitObservation {
    static func read(from buf: Reader) throws -> VisitObservation {
        return try VisitObservation(
            url: FfiConverterTypeUrl.read(buf),
            title: FfiConverterOptionString.read(from: buf),
            visitType: FfiConverterOptionEnumVisitTransition.read(from: buf),
            isError: FfiConverterOptionBool.read(from: buf),
            isRedirectSource: FfiConverterOptionBool.read(from: buf),
            isPermanentRedirectSource: FfiConverterOptionBool.read(from: buf),
            at: FfiConverterOptionTimestamp.read(from: buf),
            referrer: FfiConverterOptionUrl.read(from: buf),
            isRemote: FfiConverterOptionBool.read(from: buf),
            previewImageUrl: FfiConverterOptionUrl.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterTypeUrl.write(url, buf)
        FfiConverterOptionString.write(title, into: buf)
        FfiConverterOptionEnumVisitTransition.write(visitType, into: buf)
        FfiConverterOptionBool.write(isError, into: buf)
        FfiConverterOptionBool.write(isRedirectSource, into: buf)
        FfiConverterOptionBool.write(isPermanentRedirectSource, into: buf)
        FfiConverterOptionTimestamp.write(at, into: buf)
        FfiConverterOptionUrl.write(referrer, into: buf)
        FfiConverterOptionBool.write(isRemote, into: buf)
        FfiConverterOptionUrl.write(previewImageUrl, into: buf)
    }
}

extension VisitObservation: ViaFfiUsingByteBuffer, ViaFfi {}

public struct Dummy {
    public var md: [HistoryMetadata]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(md: [HistoryMetadata]?) {
        self.md = md
    }
}

extension Dummy: Equatable, Hashable {
    public static func == (lhs: Dummy, rhs: Dummy) -> Bool {
        if lhs.md != rhs.md {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(md)
    }
}

private extension Dummy {
    static func read(from buf: Reader) throws -> Dummy {
        return try Dummy(
            md: FfiConverterOptionSequenceRecordHistoryMetadata.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterOptionSequenceRecordHistoryMetadata.write(md, into: buf)
    }
}

extension Dummy: ViaFfiUsingByteBuffer, ViaFfi {}

public struct TopFrecentSiteInfo {
    public var url: String
    public var title: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, title: String?) {
        self.url = url
        self.title = title
    }
}

extension TopFrecentSiteInfo: Equatable, Hashable {
    public static func == (lhs: TopFrecentSiteInfo, rhs: TopFrecentSiteInfo) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(title)
    }
}

private extension TopFrecentSiteInfo {
    static func read(from buf: Reader) throws -> TopFrecentSiteInfo {
        return try TopFrecentSiteInfo(
            url: FfiConverterTypeUrl.read(buf),
            title: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterTypeUrl.write(url, buf)
        FfiConverterOptionString.write(title, into: buf)
    }
}

extension TopFrecentSiteInfo: ViaFfiUsingByteBuffer, ViaFfi {}

public struct BookmarkData {
    public var guid: String
    public var parentGuid: String
    public var position: UInt32
    public var dateAdded: Int64
    public var lastModified: Int64
    public var url: String
    public var title: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: String, parentGuid: String, position: UInt32, dateAdded: Int64, lastModified: Int64, url: String, title: String?) {
        self.guid = guid
        self.parentGuid = parentGuid
        self.position = position
        self.dateAdded = dateAdded
        self.lastModified = lastModified
        self.url = url
        self.title = title
    }
}

extension BookmarkData: Equatable, Hashable {
    public static func == (lhs: BookmarkData, rhs: BookmarkData) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(parentGuid)
        hasher.combine(position)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
        hasher.combine(url)
        hasher.combine(title)
    }
}

private extension BookmarkData {
    static func read(from buf: Reader) throws -> BookmarkData {
        return try BookmarkData(
            guid: FfiConverterTypeGuid.read(buf),
            parentGuid: FfiConverterTypeGuid.read(buf),
            position: UInt32.read(from: buf),
            dateAdded: FfiConverterTypeTimestamp.read(buf),
            lastModified: FfiConverterTypeTimestamp.read(buf),
            url: FfiConverterTypeUrl.read(buf),
            title: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterTypeGuid.write(guid, buf)
        FfiConverterTypeGuid.write(parentGuid, buf)
        position.write(into: buf)
        FfiConverterTypeTimestamp.write(dateAdded, buf)
        FfiConverterTypeTimestamp.write(lastModified, buf)
        FfiConverterTypeUrl.write(url, buf)
        FfiConverterOptionString.write(title, into: buf)
    }
}

extension BookmarkData: ViaFfiUsingByteBuffer, ViaFfi {}

public struct BookmarkSeparator {
    public var guid: String
    public var dateAdded: Int64
    public var lastModified: Int64
    public var parentGuid: String
    public var position: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: String, dateAdded: Int64, lastModified: Int64, parentGuid: String, position: UInt32) {
        self.guid = guid
        self.dateAdded = dateAdded
        self.lastModified = lastModified
        self.parentGuid = parentGuid
        self.position = position
    }
}

extension BookmarkSeparator: Equatable, Hashable {
    public static func == (lhs: BookmarkSeparator, rhs: BookmarkSeparator) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
        hasher.combine(parentGuid)
        hasher.combine(position)
    }
}

private extension BookmarkSeparator {
    static func read(from buf: Reader) throws -> BookmarkSeparator {
        return try BookmarkSeparator(
            guid: FfiConverterTypeGuid.read(buf),
            dateAdded: FfiConverterTypeTimestamp.read(buf),
            lastModified: FfiConverterTypeTimestamp.read(buf),
            parentGuid: FfiConverterTypeGuid.read(buf),
            position: UInt32.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterTypeGuid.write(guid, buf)
        FfiConverterTypeTimestamp.write(dateAdded, buf)
        FfiConverterTypeTimestamp.write(lastModified, buf)
        FfiConverterTypeGuid.write(parentGuid, buf)
        position.write(into: buf)
    }
}

extension BookmarkSeparator: ViaFfiUsingByteBuffer, ViaFfi {}

public struct BookmarkFolder {
    public var guid: String
    public var dateAdded: Int64
    public var lastModified: Int64
    public var parentGuid: String?
    public var position: UInt32
    public var title: String?
    public var childGuids: [String]?
    public var childNodes: [BookmarkItem]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: String, dateAdded: Int64, lastModified: Int64, parentGuid: String?, position: UInt32, title: String?, childGuids: [String]?, childNodes: [BookmarkItem]?) {
        self.guid = guid
        self.dateAdded = dateAdded
        self.lastModified = lastModified
        self.parentGuid = parentGuid
        self.position = position
        self.title = title
        self.childGuids = childGuids
        self.childNodes = childNodes
    }
}

extension BookmarkFolder: Equatable, Hashable {
    public static func == (lhs: BookmarkFolder, rhs: BookmarkFolder) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.childGuids != rhs.childGuids {
            return false
        }
        if lhs.childNodes != rhs.childNodes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
        hasher.combine(parentGuid)
        hasher.combine(position)
        hasher.combine(title)
        hasher.combine(childGuids)
        hasher.combine(childNodes)
    }
}

private extension BookmarkFolder {
    static func read(from buf: Reader) throws -> BookmarkFolder {
        return try BookmarkFolder(
            guid: FfiConverterTypeGuid.read(buf),
            dateAdded: FfiConverterTypeTimestamp.read(buf),
            lastModified: FfiConverterTypeTimestamp.read(buf),
            parentGuid: FfiConverterOptionGuid.read(from: buf),
            position: UInt32.read(from: buf),
            title: FfiConverterOptionString.read(from: buf),
            childGuids: FfiConverterOptionSequenceGuid.read(from: buf),
            childNodes: FfiConverterOptionSequenceEnumBookmarkItem.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterTypeGuid.write(guid, buf)
        FfiConverterTypeTimestamp.write(dateAdded, buf)
        FfiConverterTypeTimestamp.write(lastModified, buf)
        FfiConverterOptionGuid.write(parentGuid, into: buf)
        position.write(into: buf)
        FfiConverterOptionString.write(title, into: buf)
        FfiConverterOptionSequenceGuid.write(childGuids, into: buf)
        FfiConverterOptionSequenceEnumBookmarkItem.write(childNodes, into: buf)
    }
}

extension BookmarkFolder: ViaFfiUsingByteBuffer, ViaFfi {}

public struct BookmarkUpdateInfo {
    public var guid: String
    public var title: String?
    public var url: String?
    public var parentGuid: String?
    public var position: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: String, title: String?, url: String?, parentGuid: String?, position: UInt32?) {
        self.guid = guid
        self.title = title
        self.url = url
        self.parentGuid = parentGuid
        self.position = position
    }
}

extension BookmarkUpdateInfo: Equatable, Hashable {
    public static func == (lhs: BookmarkUpdateInfo, rhs: BookmarkUpdateInfo) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(title)
        hasher.combine(url)
        hasher.combine(parentGuid)
        hasher.combine(position)
    }
}

private extension BookmarkUpdateInfo {
    static func read(from buf: Reader) throws -> BookmarkUpdateInfo {
        return try BookmarkUpdateInfo(
            guid: FfiConverterTypeGuid.read(buf),
            title: FfiConverterOptionString.read(from: buf),
            url: FfiConverterOptionString.read(from: buf),
            parentGuid: FfiConverterOptionGuid.read(from: buf),
            position: FfiConverterOptionUInt32.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterTypeGuid.write(guid, buf)
        FfiConverterOptionString.write(title, into: buf)
        FfiConverterOptionString.write(url, into: buf)
        FfiConverterOptionGuid.write(parentGuid, into: buf)
        FfiConverterOptionUInt32.write(position, into: buf)
    }
}

extension BookmarkUpdateInfo: ViaFfiUsingByteBuffer, ViaFfi {}

public struct InsertableBookmark {
    public var guid: String?
    public var parentGuid: String
    public var position: BookmarkPosition
    public var dateAdded: Int64?
    public var lastModified: Int64?
    public var url: String
    public var title: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: String? = nil, parentGuid: String, position: BookmarkPosition, dateAdded: Int64? = nil, lastModified: Int64? = nil, url: String, title: String? = nil) {
        self.guid = guid
        self.parentGuid = parentGuid
        self.position = position
        self.dateAdded = dateAdded
        self.lastModified = lastModified
        self.url = url
        self.title = title
    }
}

extension InsertableBookmark: Equatable, Hashable {
    public static func == (lhs: InsertableBookmark, rhs: InsertableBookmark) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(parentGuid)
        hasher.combine(position)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
        hasher.combine(url)
        hasher.combine(title)
    }
}

private extension InsertableBookmark {
    static func read(from buf: Reader) throws -> InsertableBookmark {
        return try InsertableBookmark(
            guid: FfiConverterOptionGuid.read(from: buf),
            parentGuid: FfiConverterTypeGuid.read(buf),
            position: BookmarkPosition.read(from: buf),
            dateAdded: FfiConverterOptionTimestamp.read(from: buf),
            lastModified: FfiConverterOptionTimestamp.read(from: buf),
            url: FfiConverterTypeUrl.read(buf),
            title: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterOptionGuid.write(guid, into: buf)
        FfiConverterTypeGuid.write(parentGuid, buf)
        position.write(into: buf)
        FfiConverterOptionTimestamp.write(dateAdded, into: buf)
        FfiConverterOptionTimestamp.write(lastModified, into: buf)
        FfiConverterTypeUrl.write(url, buf)
        FfiConverterOptionString.write(title, into: buf)
    }
}

extension InsertableBookmark: ViaFfiUsingByteBuffer, ViaFfi {}

public struct InsertableBookmarkSeparator {
    public var guid: String?
    public var parentGuid: String
    public var position: BookmarkPosition
    public var dateAdded: Int64?
    public var lastModified: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: String? = nil, parentGuid: String, position: BookmarkPosition, dateAdded: Int64? = nil, lastModified: Int64? = nil) {
        self.guid = guid
        self.parentGuid = parentGuid
        self.position = position
        self.dateAdded = dateAdded
        self.lastModified = lastModified
    }
}

extension InsertableBookmarkSeparator: Equatable, Hashable {
    public static func == (lhs: InsertableBookmarkSeparator, rhs: InsertableBookmarkSeparator) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(parentGuid)
        hasher.combine(position)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
    }
}

private extension InsertableBookmarkSeparator {
    static func read(from buf: Reader) throws -> InsertableBookmarkSeparator {
        return try InsertableBookmarkSeparator(
            guid: FfiConverterOptionGuid.read(from: buf),
            parentGuid: FfiConverterTypeGuid.read(buf),
            position: BookmarkPosition.read(from: buf),
            dateAdded: FfiConverterOptionTimestamp.read(from: buf),
            lastModified: FfiConverterOptionTimestamp.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterOptionGuid.write(guid, into: buf)
        FfiConverterTypeGuid.write(parentGuid, buf)
        position.write(into: buf)
        FfiConverterOptionTimestamp.write(dateAdded, into: buf)
        FfiConverterOptionTimestamp.write(lastModified, into: buf)
    }
}

extension InsertableBookmarkSeparator: ViaFfiUsingByteBuffer, ViaFfi {}

public struct InsertableBookmarkFolder {
    public var guid: String?
    public var parentGuid: String
    public var position: BookmarkPosition
    public var dateAdded: Int64?
    public var lastModified: Int64?
    public var title: String?
    public var children: [InsertableBookmarkItem]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: String? = nil, parentGuid: String, position: BookmarkPosition, dateAdded: Int64? = nil, lastModified: Int64? = nil, title: String? = nil, children: [InsertableBookmarkItem]) {
        self.guid = guid
        self.parentGuid = parentGuid
        self.position = position
        self.dateAdded = dateAdded
        self.lastModified = lastModified
        self.title = title
        self.children = children
    }
}

extension InsertableBookmarkFolder: Equatable, Hashable {
    public static func == (lhs: InsertableBookmarkFolder, rhs: InsertableBookmarkFolder) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.children != rhs.children {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(parentGuid)
        hasher.combine(position)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
        hasher.combine(title)
        hasher.combine(children)
    }
}

private extension InsertableBookmarkFolder {
    static func read(from buf: Reader) throws -> InsertableBookmarkFolder {
        return try InsertableBookmarkFolder(
            guid: FfiConverterOptionGuid.read(from: buf),
            parentGuid: FfiConverterTypeGuid.read(buf),
            position: BookmarkPosition.read(from: buf),
            dateAdded: FfiConverterOptionTimestamp.read(from: buf),
            lastModified: FfiConverterOptionTimestamp.read(from: buf),
            title: FfiConverterOptionString.read(from: buf),
            children: FfiConverterSequenceEnumInsertableBookmarkItem.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterOptionGuid.write(guid, into: buf)
        FfiConverterTypeGuid.write(parentGuid, buf)
        position.write(into: buf)
        FfiConverterOptionTimestamp.write(dateAdded, into: buf)
        FfiConverterOptionTimestamp.write(lastModified, into: buf)
        FfiConverterOptionString.write(title, into: buf)
        FfiConverterSequenceEnumInsertableBookmarkItem.write(children, into: buf)
    }
}

extension InsertableBookmarkFolder: ViaFfiUsingByteBuffer, ViaFfi {}

public enum PlacesError {
    // Simple error enums only carry a message
    case UnexpectedPlacesException(message: String)

    // Simple error enums only carry a message
    case UrlParseFailed(message: String)

    // Simple error enums only carry a message
    case JsonParseFailed(message: String)

    // Simple error enums only carry a message
    case PlacesConnectionBusy(message: String)

    // Simple error enums only carry a message
    case OperationInterrupted(message: String)

    // Simple error enums only carry a message
    case BookmarksCorruption(message: String)

    // Simple error enums only carry a message
    case InvalidParent(message: String)

    // Simple error enums only carry a message
    case UnknownBookmarkItem(message: String)

    // Simple error enums only carry a message
    case UrlTooLong(message: String)

    // Simple error enums only carry a message
    case InvalidBookmarkUpdate(message: String)

    // Simple error enums only carry a message
    case CannotUpdateRoot(message: String)

    // Simple error enums only carry a message
    case InternalPanic(message: String)
}

extension PlacesError: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> PlacesError {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .UnexpectedPlacesException(
                message: try String.read(from: buf)
            )

        case 2: return .UrlParseFailed(
                message: try String.read(from: buf)
            )

        case 3: return .JsonParseFailed(
                message: try String.read(from: buf)
            )

        case 4: return .PlacesConnectionBusy(
                message: try String.read(from: buf)
            )

        case 5: return .OperationInterrupted(
                message: try String.read(from: buf)
            )

        case 6: return .BookmarksCorruption(
                message: try String.read(from: buf)
            )

        case 7: return .InvalidParent(
                message: try String.read(from: buf)
            )

        case 8: return .UnknownBookmarkItem(
                message: try String.read(from: buf)
            )

        case 9: return .UrlTooLong(
                message: try String.read(from: buf)
            )

        case 10: return .InvalidBookmarkUpdate(
                message: try String.read(from: buf)
            )

        case 11: return .CannotUpdateRoot(
                message: try String.read(from: buf)
            )

        case 12: return .InternalPanic(
                message: try String.read(from: buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .UnexpectedPlacesException(message):
            buf.writeInt(Int32(1))
            message.write(into: buf)
        case let .UrlParseFailed(message):
            buf.writeInt(Int32(2))
            message.write(into: buf)
        case let .JsonParseFailed(message):
            buf.writeInt(Int32(3))
            message.write(into: buf)
        case let .PlacesConnectionBusy(message):
            buf.writeInt(Int32(4))
            message.write(into: buf)
        case let .OperationInterrupted(message):
            buf.writeInt(Int32(5))
            message.write(into: buf)
        case let .BookmarksCorruption(message):
            buf.writeInt(Int32(6))
            message.write(into: buf)
        case let .InvalidParent(message):
            buf.writeInt(Int32(7))
            message.write(into: buf)
        case let .UnknownBookmarkItem(message):
            buf.writeInt(Int32(8))
            message.write(into: buf)
        case let .UrlTooLong(message):
            buf.writeInt(Int32(9))
            message.write(into: buf)
        case let .InvalidBookmarkUpdate(message):
            buf.writeInt(Int32(10))
            message.write(into: buf)
        case let .CannotUpdateRoot(message):
            buf.writeInt(Int32(11))
            message.write(into: buf)
        case let .InternalPanic(message):
            buf.writeInt(Int32(12))
            message.write(into: buf)
        }
    }
}

extension PlacesError: Equatable, Hashable {}

extension PlacesError: Error {}
private enum FfiConverterTypeGuid {
    fileprivate static func read(_ buf: Reader) throws -> String {
        return try String.read(from: buf)
    }

    fileprivate static func write(_ value: String, _ buf: Writer) {
        return value.write(into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> String {
        return try String.lift(value)
    }

    fileprivate static func lower(_ value: String) -> RustBuffer {
        return value.lower()
    }
}

private enum FfiConverterTypeTimestamp {
    fileprivate static func read(_ buf: Reader) throws -> Int64 {
        return try Int64.read(from: buf)
    }

    fileprivate static func write(_ value: Int64, _ buf: Writer) {
        return value.write(into: buf)
    }

    fileprivate static func lift(_ value: Int64) throws -> Int64 {
        return try Int64.lift(value)
    }

    fileprivate static func lower(_ value: Int64) -> Int64 {
        return value.lower()
    }
}

private enum FfiConverterTypeUrl {
    fileprivate static func read(_ buf: Reader) throws -> String {
        return try String.read(from: buf)
    }

    fileprivate static func write(_ value: String, _ buf: Writer) {
        return value.write(into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> String {
        return try String.lift(value)
    }

    fileprivate static func lower(_ value: String) -> RustBuffer {
        return value.lower()
    }
}

private enum FfiConverterTypeVisitTransitionSet {
    fileprivate static func read(_ buf: Reader) throws -> Int32 {
        return try Int32.read(from: buf)
    }

    fileprivate static func write(_ value: Int32, _ buf: Writer) {
        return value.write(into: buf)
    }

    fileprivate static func lift(_ value: Int32) throws -> Int32 {
        return try Int32.lift(value)
    }

    fileprivate static func lower(_ value: Int32) -> Int32 {
        return value.lower()
    }
}

extension UInt32: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension Int32: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension Int64: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension Double: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readDouble())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeDouble(lower())
    }
}

extension Bool: ViaFfi {
    fileprivate typealias FfiType = Int8

    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }

    fileprivate static func lift(_ v: FfiType) throws -> Self {
        return v != 0
    }

    fileprivate func lower() -> FfiType {
        return self ? 1 : 0
    }
}

extension String: ViaFfi {
    fileprivate typealias FfiType = RustBuffer

    fileprivate static func lift(_ v: FfiType) throws -> Self {
        defer {
            v.deallocate()
        }
        if v.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: v.data!, count: Int(v.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    fileprivate func lower() -> FfiType {
        return utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    fileprivate static func read(from buf: Reader) throws -> Self {
        let len: Int32 = try buf.readInt()
        return String(bytes: try buf.readBytes(count: Int(len)), encoding: String.Encoding.utf8)!
    }

    fileprivate func write(into buf: Writer) {
        let len = Int32(utf8.count)
        buf.writeInt(len)
        buf.writeBytes(utf8)
    }
}

// Helper code for PlacesApi class is found in ObjectTemplate.swift
// Helper code for PlacesConnection class is found in ObjectTemplate.swift
// Helper code for SqlInterruptHandle class is found in ObjectTemplate.swift
// Helper code for BookmarkData record is found in RecordTemplate.swift
// Helper code for BookmarkFolder record is found in RecordTemplate.swift
// Helper code for BookmarkSeparator record is found in RecordTemplate.swift
// Helper code for BookmarkUpdateInfo record is found in RecordTemplate.swift
// Helper code for Dummy record is found in RecordTemplate.swift
// Helper code for HistoryHighlight record is found in RecordTemplate.swift
// Helper code for HistoryHighlightWeights record is found in RecordTemplate.swift
// Helper code for HistoryMetadata record is found in RecordTemplate.swift
// Helper code for HistoryMetadataObservation record is found in RecordTemplate.swift
// Helper code for HistoryVisitInfo record is found in RecordTemplate.swift
// Helper code for HistoryVisitInfosWithBound record is found in RecordTemplate.swift
// Helper code for InsertableBookmark record is found in RecordTemplate.swift
// Helper code for InsertableBookmarkFolder record is found in RecordTemplate.swift
// Helper code for InsertableBookmarkSeparator record is found in RecordTemplate.swift
// Helper code for SearchResult record is found in RecordTemplate.swift
// Helper code for TopFrecentSiteInfo record is found in RecordTemplate.swift
// Helper code for VisitObservation record is found in RecordTemplate.swift
// Helper code for BookmarkItem enum is found in EnumTemplate.swift
// Helper code for BookmarkPosition enum is found in EnumTemplate.swift
// Helper code for ConnectionType enum is found in EnumTemplate.swift
// Helper code for DocumentType enum is found in EnumTemplate.swift
// Helper code for FrecencyThresholdOption enum is found in EnumTemplate.swift
// Helper code for InsertableBookmarkItem enum is found in EnumTemplate.swift
// Helper code for MatchReason enum is found in EnumTemplate.swift
// Helper code for VisitTransition enum is found in EnumTemplate.swift
// Helper code for PlacesError error is found in ErrorTemplate.swift

private enum FfiConverterOptionUInt32: FfiConverterUsingByteBuffer {
    typealias SwiftType = UInt32?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try UInt32.read(from: buf)
        }
    }
}

private enum FfiConverterOptionInt32: FfiConverterUsingByteBuffer {
    typealias SwiftType = Int32?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try Int32.read(from: buf)
        }
    }
}

private enum FfiConverterOptionBool: FfiConverterUsingByteBuffer {
    typealias SwiftType = Bool?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try Bool.read(from: buf)
        }
    }
}

private enum FfiConverterOptionString: FfiConverterUsingByteBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try String.read(from: buf)
        }
    }
}

private enum FfiConverterOptionRecordHistoryMetadata: FfiConverterUsingByteBuffer {
    typealias SwiftType = HistoryMetadata?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try HistoryMetadata.read(from: buf)
        }
    }
}

private enum FfiConverterOptionEnumBookmarkItem: FfiConverterUsingByteBuffer {
    typealias SwiftType = BookmarkItem?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try BookmarkItem.read(from: buf)
        }
    }
}

private enum FfiConverterOptionEnumDocumentType: FfiConverterUsingByteBuffer {
    typealias SwiftType = DocumentType?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try DocumentType.read(from: buf)
        }
    }
}

private enum FfiConverterOptionEnumVisitTransition: FfiConverterUsingByteBuffer {
    typealias SwiftType = VisitTransition?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try VisitTransition.read(from: buf)
        }
    }
}

private enum FfiConverterOptionSequenceRecordHistoryMetadata: FfiConverterUsingByteBuffer {
    typealias SwiftType = [HistoryMetadata]?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            FfiConverterSequenceRecordHistoryMetadata.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try FfiConverterSequenceRecordHistoryMetadata.read(from: buf)
        }
    }
}

private enum FfiConverterOptionSequenceEnumBookmarkItem: FfiConverterUsingByteBuffer {
    typealias SwiftType = [BookmarkItem]?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            FfiConverterSequenceEnumBookmarkItem.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try FfiConverterSequenceEnumBookmarkItem.read(from: buf)
        }
    }
}

private enum FfiConverterOptionSequenceGuid: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String]?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            FfiConverterSequenceGuid.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try FfiConverterSequenceGuid.read(from: buf)
        }
    }
}

private enum FfiConverterOptionGuid: FfiConverterUsingByteBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            FfiConverterTypeGuid.write(item, buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try FfiConverterTypeGuid.read(buf)
        }
    }
}

private enum FfiConverterOptionTimestamp: FfiConverterUsingByteBuffer {
    typealias SwiftType = Int64?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            FfiConverterTypeTimestamp.write(item, buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try FfiConverterTypeTimestamp.read(buf)
        }
    }
}

private enum FfiConverterOptionUrl: FfiConverterUsingByteBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            FfiConverterTypeUrl.write(item, buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try FfiConverterTypeUrl.read(buf)
        }
    }
}

private enum FfiConverterSequenceBool: FfiConverterUsingByteBuffer {
    typealias SwiftType = [Bool]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try Bool.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceString: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try String.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordHistoryHighlight: FfiConverterUsingByteBuffer {
    typealias SwiftType = [HistoryHighlight]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try HistoryHighlight.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordHistoryMetadata: FfiConverterUsingByteBuffer {
    typealias SwiftType = [HistoryMetadata]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try HistoryMetadata.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordHistoryVisitInfo: FfiConverterUsingByteBuffer {
    typealias SwiftType = [HistoryVisitInfo]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try HistoryVisitInfo.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordSearchResult: FfiConverterUsingByteBuffer {
    typealias SwiftType = [SearchResult]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try SearchResult.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordTopFrecentSiteInfo: FfiConverterUsingByteBuffer {
    typealias SwiftType = [TopFrecentSiteInfo]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try TopFrecentSiteInfo.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceEnumBookmarkItem: FfiConverterUsingByteBuffer {
    typealias SwiftType = [BookmarkItem]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try BookmarkItem.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceEnumInsertableBookmarkItem: FfiConverterUsingByteBuffer {
    typealias SwiftType = [InsertableBookmarkItem]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try InsertableBookmarkItem.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceEnumMatchReason: FfiConverterUsingByteBuffer {
    typealias SwiftType = [MatchReason]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try MatchReason.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceGuid: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            FfiConverterTypeGuid.write(item, buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try FfiConverterTypeGuid.read(buf)
        }
    }
}

private enum FfiConverterSequenceUrl: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            FfiConverterTypeUrl.write(item, buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try FfiConverterTypeUrl.read(buf)
        }
    }
}

// Helper code for Guid is found in CustomType.py
// Helper code for Timestamp is found in CustomType.py
// Helper code for Url is found in CustomType.py
// Helper code for VisitTransitionSet is found in CustomType.py

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum PlacesLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
        // No initialization code needed
    }
}
