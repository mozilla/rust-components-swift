// -*- mode: Swift -*-

// AUTOGENERATED BY glean_parser. DO NOT EDIT. DO NOT COMMIT.

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */



import Glean

// swiftlint:disable superfluous_disable_command
// swiftlint:disable nesting
// swiftlint:disable line_length
// swiftlint:disable identifier_name
// swiftlint:disable force_try

extension GleanMetrics {
    class GleanBuild {
        private init() {
            // Intentionally left private, no external user can instantiate a new global object.
        }

        public static let info = BuildInfo(buildDate: DateComponents(calendar: Calendar.current, timeZone: TimeZone(abbreviation: "UTC"), year: 2022, month: 4, day: 27, hour: 21, minute: 18, second: 28))
    }

    enum NimbusEvents {
        struct EnrollmentExtra: EventExtras {
            var branch: String?
            var enrollmentId: String?
            var experiment: String?

            func toFfiExtra() -> ([Int32], [String]) {
                var keys = [Int32]()
                var values = [String]()

                if let branch = self.branch {
                    keys.append(0)
                    values.append(String(branch))
                }
                if let enrollmentId = self.enrollmentId {
                    keys.append(1)
                    values.append(String(enrollmentId))
                }
                if let experiment = self.experiment {
                    keys.append(2)
                    values.append(String(experiment))
                }

                return (keys, values)
            }
        }

        struct UnenrollmentExtra: EventExtras {
            var branch: String?
            var enrollmentId: String?
            var experiment: String?

            func toFfiExtra() -> ([Int32], [String]) {
                var keys = [Int32]()
                var values = [String]()

                if let branch = self.branch {
                    keys.append(0)
                    values.append(String(branch))
                }
                if let enrollmentId = self.enrollmentId {
                    keys.append(1)
                    values.append(String(enrollmentId))
                }
                if let experiment = self.experiment {
                    keys.append(2)
                    values.append(String(experiment))
                }

                return (keys, values)
            }
        }

        struct DisqualificationExtra: EventExtras {
            var branch: String?
            var enrollmentId: String?
            var experiment: String?

            func toFfiExtra() -> ([Int32], [String]) {
                var keys = [Int32]()
                var values = [String]()

                if let branch = self.branch {
                    keys.append(0)
                    values.append(String(branch))
                }
                if let enrollmentId = self.enrollmentId {
                    keys.append(1)
                    values.append(String(enrollmentId))
                }
                if let experiment = self.experiment {
                    keys.append(2)
                    values.append(String(experiment))
                }

                return (keys, values)
            }
        }

        struct ExposureExtra: EventExtras {
            var branch: String?
            var enrollmentId: String?
            var experiment: String?

            func toFfiExtra() -> ([Int32], [String]) {
                var keys = [Int32]()
                var values = [String]()

                if let branch = self.branch {
                    keys.append(0)
                    values.append(String(branch))
                }
                if let enrollmentId = self.enrollmentId {
                    keys.append(1)
                    values.append(String(enrollmentId))
                }
                if let experiment = self.experiment {
                    keys.append(2)
                    values.append(String(experiment))
                }

                return (keys, values)
            }
        }

        /// Recorded when a user has met the conditions and is first bucketed into an
        /// experiment (i.e. targeting matched and they were randomized into a bucket and
        /// branch of the experiment). Expected a maximum of once per experiment per user.
        static let enrollment = EventMetricType<NoExtraKeys, EnrollmentExtra>( // generated from nimbus_events.enrollment
            category: "nimbus_events",
            name: "enrollment",
            sendInPings: ["events"],
            lifetime: .ping,
            disabled: false,
            allowedExtraKeys: ["branch", "enrollment_id", "experiment"]
        )

        /// Recorded when either telemetry is disabled, or the experiment has run for its
        /// designed duration (i.e. it is no longer present in the Nimbus Remote Settings
        /// collection)
        static let unenrollment = EventMetricType<NoExtraKeys, UnenrollmentExtra>( // generated from nimbus_events.unenrollment
            category: "nimbus_events",
            name: "unenrollment",
            sendInPings: ["events"],
            lifetime: .ping,
            disabled: false,
            allowedExtraKeys: ["branch", "enrollment_id", "experiment"]
        )

        /// Recorded when a user becomes ineligible to continue receiving the treatment for
        /// an enrolled experiment, for reasons such as the user opting out of the
        /// experiment or no longer matching targeting for the experiment.
        static let disqualification = EventMetricType<NoExtraKeys, DisqualificationExtra>( // generated from nimbus_events.disqualification
            category: "nimbus_events",
            name: "disqualification",
            sendInPings: ["events"],
            lifetime: .ping,
            disabled: false,
            allowedExtraKeys: ["branch", "enrollment_id", "experiment"]
        )

        /// Recorded when a user actually observes an experimental treatment, or would have
        /// observed an experimental treatment if they had been in a branch that would have
        /// shown one.
        static let exposure = EventMetricType<NoExtraKeys, ExposureExtra>( // generated from nimbus_events.exposure
            category: "nimbus_events",
            name: "exposure",
            sendInPings: ["events"],
            lifetime: .ping,
            disabled: false,
            allowedExtraKeys: ["branch", "enrollment_id", "experiment"]
        )

    }

    enum LoginsStoreMigration {
        /// The total number of login records processed by the migration
        static let numProcessed = CounterMetricType( // generated from logins_store_migration.num_processed
            category: "logins_store_migration",
            name: "num_processed",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false
        )

        /// The total number of login records successfully migrated
        static let numSucceeded = CounterMetricType( // generated from logins_store_migration.num_succeeded
            category: "logins_store_migration",
            name: "num_succeeded",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false
        )

        /// The total number of login records which failed to migrate
        static let numFailed = CounterMetricType( // generated from logins_store_migration.num_failed
            category: "logins_store_migration",
            name: "num_failed",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false
        )

        /// How long the migration tool
        static let totalDuration = TimespanMetricType( // generated from logins_store_migration.total_duration
            category: "logins_store_migration",
            name: "total_duration",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false,
            timeUnit: .millisecond
        )

        /// Errors discovered in the migration.
        static let errors = StringListMetricType( // generated from logins_store_migration.errors
            category: "logins_store_migration",
            name: "errors",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false
        )

    }

}
