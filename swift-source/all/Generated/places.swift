// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(MozillaRustComponents)
    import MozillaRustComponents
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_places_3413_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_places_3413_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// A helper class to read values out of a byte buffer.
private class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset ..< offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        let _ = withUnsafeMutableBytes(of: &value) { data.copyBytes(to: $0, from: range) }
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads an arbitrary number of bytes, to be used to read
    // raw bytes, this is useful when lifting strings
    func readBytes(count: Int) throws -> [UInt8] {
        let range = offset ..< (offset + count)
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        var value = [UInt8](repeating: 0, count: count)
        value.withUnsafeMutableBufferPointer { buffer in
            data.copyBytes(to: buffer, from: range)
        }
        offset = range.upperBound
        return value
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
private class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        bytes = []
        offset = 0
    }

    func writeBytes<S>(_ byteArr: S) where S: Sequence, S.Element == UInt8 {
        bytes.append(contentsOf: byteArr)
    }

    // Writes an integer in big-endian order.
    //
    // Warning: make sure what you are trying to write
    // is in the correct type!
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        withUnsafeBytes(of: &value) { bytes.append(contentsOf: $0) }
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: Reader) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: Writer)
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    static func lift(_ buf: RustBuffer) throws -> SwiftType {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    static func lower(_ value: SwiftType) -> RustBuffer {
        let writer = Writer()
        write(value, into: writer)
        return RustBuffer(bytes: writer.bytes)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
(_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
{
    try makeRustCall(callback, errorHandler: { try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    static func read(from buf: Reader) throws -> UInt32 {
        return try lift(buf.readInt())
    }

    static func write(_ value: SwiftType, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    static func read(from buf: Reader) throws -> Int32 {
        return try lift(buf.readInt())
    }

    static func write(_ value: Int32, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    static func read(from buf: Reader) throws -> UInt64 {
        return try lift(buf.readInt())
    }

    static func write(_ value: SwiftType, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    static func read(from buf: Reader) throws -> Int64 {
        return try lift(buf.readInt())
    }

    static func write(_ value: Int64, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    static func read(from buf: Reader) throws -> Double {
        return try lift(buf.readDouble())
    }

    static func write(_ value: Double, into buf: Writer) {
        buf.writeDouble(lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    static func read(from buf: Reader) throws -> Bool {
        return try lift(buf.readInt())
    }

    static func write(_ value: Bool, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    static func read(from buf: Reader) throws -> String {
        let len: Int32 = try buf.readInt()
        return String(bytes: try buf.readBytes(count: Int(len)), encoding: String.Encoding.utf8)!
    }

    static func write(_ value: String, into buf: Writer) {
        let len = Int32(value.utf8.count)
        buf.writeInt(len)
        buf.writeBytes(value.utf8)
    }
}

public protocol PlacesApiProtocol {
    func newConnection(connType: ConnectionType) throws -> PlacesConnection
    func registerWithSyncManager()
    func resetHistory() throws
    func historySync(keyId: String, accessToken: String, syncKey: String, tokenserverUrl: Url) throws -> String
    func bookmarksSync(keyId: String, accessToken: String, syncKey: String, tokenserverUrl: Url) throws -> String
    func placesPinnedSitesImportFromFennec(dbPath: String) throws -> [BookmarkItem]
    func placesHistoryImportFromFennec(dbPath: String) throws -> String
    func placesBookmarksImportFromFennec(dbPath: String) throws -> String
    func placesBookmarksImportFromIos(dbPath: String) throws
    func bookmarksReset() throws
}

public class PlacesApi: PlacesApiProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_places_3413_PlacesApi_object_free(pointer, $0) }
    }

    public func newConnection(connType: ConnectionType) throws -> PlacesConnection {
        return try FfiConverterTypePlacesConnection.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesApi_new_connection(self.pointer,
                                                         FfiConverterTypeConnectionType.lower(connType), $0)
                }
        )
    }

    public func registerWithSyncManager() {
        try!
            rustCall {
                places_3413_PlacesApi_register_with_sync_manager(self.pointer, $0)
            }
    }

    public func resetHistory() throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesApi_reset_history(self.pointer, $0)
            }
    }

    public func historySync(keyId: String, accessToken: String, syncKey: String, tokenserverUrl: Url) throws -> String {
        return try FfiConverterString.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesApi_history_sync(self.pointer,
                                                       FfiConverterString.lower(keyId),
                                                       FfiConverterString.lower(accessToken),
                                                       FfiConverterString.lower(syncKey),
                                                       FfiConverterTypeUrl.lower(tokenserverUrl), $0)
                }
        )
    }

    public func bookmarksSync(keyId: String, accessToken: String, syncKey: String, tokenserverUrl: Url) throws -> String {
        return try FfiConverterString.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesApi_bookmarks_sync(self.pointer,
                                                         FfiConverterString.lower(keyId),
                                                         FfiConverterString.lower(accessToken),
                                                         FfiConverterString.lower(syncKey),
                                                         FfiConverterTypeUrl.lower(tokenserverUrl), $0)
                }
        )
    }

    public func placesPinnedSitesImportFromFennec(dbPath: String) throws -> [BookmarkItem] {
        return try FfiConverterSequenceTypeBookmarkItem.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesApi_places_pinned_sites_import_from_fennec(self.pointer,
                                                                                 FfiConverterString.lower(dbPath), $0)
                }
        )
    }

    public func placesHistoryImportFromFennec(dbPath: String) throws -> String {
        return try FfiConverterString.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesApi_places_history_import_from_fennec(self.pointer,
                                                                            FfiConverterString.lower(dbPath), $0)
                }
        )
    }

    public func placesBookmarksImportFromFennec(dbPath: String) throws -> String {
        return try FfiConverterString.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesApi_places_bookmarks_import_from_fennec(self.pointer,
                                                                              FfiConverterString.lower(dbPath), $0)
                }
        )
    }

    public func placesBookmarksImportFromIos(dbPath: String) throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesApi_places_bookmarks_import_from_ios(self.pointer,
                                                                       FfiConverterString.lower(dbPath), $0)
            }
    }

    public func bookmarksReset() throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesApi_bookmarks_reset(self.pointer, $0)
            }
    }
}

private struct FfiConverterTypePlacesApi: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PlacesApi

    static func read(from buf: Reader) throws -> PlacesApi {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: PlacesApi, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PlacesApi {
        return PlacesApi(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: PlacesApi) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol PlacesConnectionProtocol {
    func newInterruptHandle() -> SqlInterruptHandle
    func getLatestHistoryMetadataForUrl(url: Url) throws -> HistoryMetadata?
    func getHistoryMetadataBetween(start: PlacesTimestamp, end: PlacesTimestamp) throws -> [HistoryMetadata]
    func getHistoryMetadataSince(since: PlacesTimestamp) throws -> [HistoryMetadata]
    func queryAutocomplete(search: String, limit: Int32) throws -> [SearchResult]
    func acceptResult(searchString: String, url: String) throws
    func matchUrl(query: String) throws -> Url?
    func queryHistoryMetadata(query: String, limit: Int32) throws -> [HistoryMetadata]
    func getHistoryHighlights(weights: HistoryHighlightWeights, limit: Int32) throws -> [HistoryHighlight]
    func noteHistoryMetadataObservation(data: HistoryMetadataObservation) throws
    func metadataDelete(url: Url, referrerUrl: Url?, searchTerm: String?) throws
    func metadataDeleteOlderThan(olderThan: PlacesTimestamp) throws
    func applyObservation(visit: VisitObservation) throws
    func getVisitedUrlsInRange(start: PlacesTimestamp, end: PlacesTimestamp, includeRemote: Bool) throws -> [Url]
    func getVisitInfos(startDate: PlacesTimestamp, endDate: PlacesTimestamp, excludeTypes: VisitTransitionSet) throws -> [HistoryVisitInfo]
    func getVisitCount(excludeTypes: VisitTransitionSet) throws -> Int64
    func getVisitPage(offset: Int64, count: Int64, excludeTypes: VisitTransitionSet) throws -> [HistoryVisitInfo]
    func getVisitPageWithBound(bound: Int64, offset: Int64, count: Int64, excludeTypes: VisitTransitionSet) throws -> HistoryVisitInfosWithBound
    func getVisited(urls: [String]) throws -> [Bool]
    func deleteVisitsFor(url: String) throws
    func deleteVisitsBetween(start: PlacesTimestamp, end: PlacesTimestamp) throws
    func deleteVisit(url: String, timestamp: PlacesTimestamp) throws
    func getTopFrecentSiteInfos(numItems: Int32, thresholdOption: FrecencyThresholdOption) throws -> [TopFrecentSiteInfo]
    func wipeLocalHistory() throws
    func deleteEverythingHistory() throws
    func pruneDestructively() throws
    func runMaintenance(dbSizeLimit: UInt32) throws -> RunMaintenanceMetrics
    func bookmarksGetTree(itemGuid: Guid) throws -> BookmarkItem?
    func bookmarksGetByGuid(guid: Guid, getDirectChildren: Bool) throws -> BookmarkItem?
    func bookmarksGetAllWithUrl(url: String) throws -> [BookmarkItem]
    func bookmarksSearch(query: String, limit: Int32) throws -> [BookmarkItem]
    func bookmarksGetRecent(limit: Int32) throws -> [BookmarkItem]
    func bookmarksDelete(id: Guid) throws -> Bool
    func bookmarksDeleteEverything() throws
    func bookmarksGetUrlForKeyword(keyword: String) throws -> Url?
    func bookmarksUpdate(data: BookmarkUpdateInfo) throws
    func bookmarksInsert(bookmark: InsertableBookmarkItem) throws -> Guid
    func placesHistoryImportFromIos(dbPath: String, lastSyncTimestamp: Int64) throws -> HistoryMigrationResult
}

public class PlacesConnection: PlacesConnectionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_places_3413_PlacesConnection_object_free(pointer, $0) }
    }

    public func newInterruptHandle() -> SqlInterruptHandle {
        return try! FfiConverterTypeSqlInterruptHandle.lift(
            try!
                rustCall {
                    places_3413_PlacesConnection_new_interrupt_handle(self.pointer, $0)
                }
        )
    }

    public func getLatestHistoryMetadataForUrl(url: Url) throws -> HistoryMetadata? {
        return try FfiConverterOptionTypeHistoryMetadata.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_get_latest_history_metadata_for_url(self.pointer,
                                                                                     FfiConverterTypeUrl.lower(url), $0)
                }
        )
    }

    public func getHistoryMetadataBetween(start: PlacesTimestamp, end: PlacesTimestamp) throws -> [HistoryMetadata] {
        return try FfiConverterSequenceTypeHistoryMetadata.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_get_history_metadata_between(self.pointer,
                                                                              FfiConverterTypePlacesTimestamp.lower(start),
                                                                              FfiConverterTypePlacesTimestamp.lower(end), $0)
                }
        )
    }

    public func getHistoryMetadataSince(since: PlacesTimestamp) throws -> [HistoryMetadata] {
        return try FfiConverterSequenceTypeHistoryMetadata.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_get_history_metadata_since(self.pointer,
                                                                            FfiConverterTypePlacesTimestamp.lower(since), $0)
                }
        )
    }

    public func queryAutocomplete(search: String, limit: Int32) throws -> [SearchResult] {
        return try FfiConverterSequenceTypeSearchResult.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_query_autocomplete(self.pointer,
                                                                    FfiConverterString.lower(search),
                                                                    FfiConverterInt32.lower(limit), $0)
                }
        )
    }

    public func acceptResult(searchString: String, url: String) throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_accept_result(self.pointer,
                                                           FfiConverterString.lower(searchString),
                                                           FfiConverterString.lower(url), $0)
            }
    }

    public func matchUrl(query: String) throws -> Url? {
        return try FfiConverterOptionTypeUrl.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_match_url(self.pointer,
                                                           FfiConverterString.lower(query), $0)
                }
        )
    }

    public func queryHistoryMetadata(query: String, limit: Int32) throws -> [HistoryMetadata] {
        return try FfiConverterSequenceTypeHistoryMetadata.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_query_history_metadata(self.pointer,
                                                                        FfiConverterString.lower(query),
                                                                        FfiConverterInt32.lower(limit), $0)
                }
        )
    }

    public func getHistoryHighlights(weights: HistoryHighlightWeights, limit: Int32) throws -> [HistoryHighlight] {
        return try FfiConverterSequenceTypeHistoryHighlight.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_get_history_highlights(self.pointer,
                                                                        FfiConverterTypeHistoryHighlightWeights.lower(weights),
                                                                        FfiConverterInt32.lower(limit), $0)
                }
        )
    }

    public func noteHistoryMetadataObservation(data: HistoryMetadataObservation) throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_note_history_metadata_observation(self.pointer,
                                                                               FfiConverterTypeHistoryMetadataObservation.lower(data), $0)
            }
    }

    public func metadataDelete(url: Url, referrerUrl: Url?, searchTerm: String?) throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_metadata_delete(self.pointer,
                                                             FfiConverterTypeUrl.lower(url),
                                                             FfiConverterOptionTypeUrl.lower(referrerUrl),
                                                             FfiConverterOptionString.lower(searchTerm), $0)
            }
    }

    public func metadataDeleteOlderThan(olderThan: PlacesTimestamp) throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_metadata_delete_older_than(self.pointer,
                                                                        FfiConverterTypePlacesTimestamp.lower(olderThan), $0)
            }
    }

    public func applyObservation(visit: VisitObservation) throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_apply_observation(self.pointer,
                                                               FfiConverterTypeVisitObservation.lower(visit), $0)
            }
    }

    public func getVisitedUrlsInRange(start: PlacesTimestamp, end: PlacesTimestamp, includeRemote: Bool) throws -> [Url] {
        return try FfiConverterSequenceTypeUrl.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_get_visited_urls_in_range(self.pointer,
                                                                           FfiConverterTypePlacesTimestamp.lower(start),
                                                                           FfiConverterTypePlacesTimestamp.lower(end),
                                                                           FfiConverterBool.lower(includeRemote), $0)
                }
        )
    }

    public func getVisitInfos(startDate: PlacesTimestamp, endDate: PlacesTimestamp, excludeTypes: VisitTransitionSet) throws -> [HistoryVisitInfo] {
        return try FfiConverterSequenceTypeHistoryVisitInfo.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_get_visit_infos(self.pointer,
                                                                 FfiConverterTypePlacesTimestamp.lower(startDate),
                                                                 FfiConverterTypePlacesTimestamp.lower(endDate),
                                                                 FfiConverterTypeVisitTransitionSet.lower(excludeTypes), $0)
                }
        )
    }

    public func getVisitCount(excludeTypes: VisitTransitionSet) throws -> Int64 {
        return try FfiConverterInt64.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_get_visit_count(self.pointer,
                                                                 FfiConverterTypeVisitTransitionSet.lower(excludeTypes), $0)
                }
        )
    }

    public func getVisitPage(offset: Int64, count: Int64, excludeTypes: VisitTransitionSet) throws -> [HistoryVisitInfo] {
        return try FfiConverterSequenceTypeHistoryVisitInfo.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_get_visit_page(self.pointer,
                                                                FfiConverterInt64.lower(offset),
                                                                FfiConverterInt64.lower(count),
                                                                FfiConverterTypeVisitTransitionSet.lower(excludeTypes), $0)
                }
        )
    }

    public func getVisitPageWithBound(bound: Int64, offset: Int64, count: Int64, excludeTypes: VisitTransitionSet) throws -> HistoryVisitInfosWithBound {
        return try FfiConverterTypeHistoryVisitInfosWithBound.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_get_visit_page_with_bound(self.pointer,
                                                                           FfiConverterInt64.lower(bound),
                                                                           FfiConverterInt64.lower(offset),
                                                                           FfiConverterInt64.lower(count),
                                                                           FfiConverterTypeVisitTransitionSet.lower(excludeTypes), $0)
                }
        )
    }

    public func getVisited(urls: [String]) throws -> [Bool] {
        return try FfiConverterSequenceBool.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_get_visited(self.pointer,
                                                             FfiConverterSequenceString.lower(urls), $0)
                }
        )
    }

    public func deleteVisitsFor(url: String) throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_delete_visits_for(self.pointer,
                                                               FfiConverterString.lower(url), $0)
            }
    }

    public func deleteVisitsBetween(start: PlacesTimestamp, end: PlacesTimestamp) throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_delete_visits_between(self.pointer,
                                                                   FfiConverterTypePlacesTimestamp.lower(start),
                                                                   FfiConverterTypePlacesTimestamp.lower(end), $0)
            }
    }

    public func deleteVisit(url: String, timestamp: PlacesTimestamp) throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_delete_visit(self.pointer,
                                                          FfiConverterString.lower(url),
                                                          FfiConverterTypePlacesTimestamp.lower(timestamp), $0)
            }
    }

    public func getTopFrecentSiteInfos(numItems: Int32, thresholdOption: FrecencyThresholdOption) throws -> [TopFrecentSiteInfo] {
        return try FfiConverterSequenceTypeTopFrecentSiteInfo.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_get_top_frecent_site_infos(self.pointer,
                                                                            FfiConverterInt32.lower(numItems),
                                                                            FfiConverterTypeFrecencyThresholdOption.lower(thresholdOption), $0)
                }
        )
    }

    public func wipeLocalHistory() throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_wipe_local_history(self.pointer, $0)
            }
    }

    public func deleteEverythingHistory() throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_delete_everything_history(self.pointer, $0)
            }
    }

    public func pruneDestructively() throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_prune_destructively(self.pointer, $0)
            }
    }

    public func runMaintenance(dbSizeLimit: UInt32) throws -> RunMaintenanceMetrics {
        return try FfiConverterTypeRunMaintenanceMetrics.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_run_maintenance(self.pointer,
                                                                 FfiConverterUInt32.lower(dbSizeLimit), $0)
                }
        )
    }

    public func bookmarksGetTree(itemGuid: Guid) throws -> BookmarkItem? {
        return try FfiConverterOptionTypeBookmarkItem.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_bookmarks_get_tree(self.pointer,
                                                                    FfiConverterTypeGuid.lower(itemGuid), $0)
                }
        )
    }

    public func bookmarksGetByGuid(guid: Guid, getDirectChildren: Bool) throws -> BookmarkItem? {
        return try FfiConverterOptionTypeBookmarkItem.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_bookmarks_get_by_guid(self.pointer,
                                                                       FfiConverterTypeGuid.lower(guid),
                                                                       FfiConverterBool.lower(getDirectChildren), $0)
                }
        )
    }

    public func bookmarksGetAllWithUrl(url: String) throws -> [BookmarkItem] {
        return try FfiConverterSequenceTypeBookmarkItem.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_bookmarks_get_all_with_url(self.pointer,
                                                                            FfiConverterString.lower(url), $0)
                }
        )
    }

    public func bookmarksSearch(query: String, limit: Int32) throws -> [BookmarkItem] {
        return try FfiConverterSequenceTypeBookmarkItem.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_bookmarks_search(self.pointer,
                                                                  FfiConverterString.lower(query),
                                                                  FfiConverterInt32.lower(limit), $0)
                }
        )
    }

    public func bookmarksGetRecent(limit: Int32) throws -> [BookmarkItem] {
        return try FfiConverterSequenceTypeBookmarkItem.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_bookmarks_get_recent(self.pointer,
                                                                      FfiConverterInt32.lower(limit), $0)
                }
        )
    }

    public func bookmarksDelete(id: Guid) throws -> Bool {
        return try FfiConverterBool.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_bookmarks_delete(self.pointer,
                                                                  FfiConverterTypeGuid.lower(id), $0)
                }
        )
    }

    public func bookmarksDeleteEverything() throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_bookmarks_delete_everything(self.pointer, $0)
            }
    }

    public func bookmarksGetUrlForKeyword(keyword: String) throws -> Url? {
        return try FfiConverterOptionTypeUrl.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_bookmarks_get_url_for_keyword(self.pointer,
                                                                               FfiConverterString.lower(keyword), $0)
                }
        )
    }

    public func bookmarksUpdate(data: BookmarkUpdateInfo) throws {
        try
            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_PlacesConnection_bookmarks_update(self.pointer,
                                                              FfiConverterTypeBookmarkUpdateInfo.lower(data), $0)
            }
    }

    public func bookmarksInsert(bookmark: InsertableBookmarkItem) throws -> Guid {
        return try FfiConverterTypeGuid.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_bookmarks_insert(self.pointer,
                                                                  FfiConverterTypeInsertableBookmarkItem.lower(bookmark), $0)
                }
        )
    }

    public func placesHistoryImportFromIos(dbPath: String, lastSyncTimestamp: Int64) throws -> HistoryMigrationResult {
        return try FfiConverterTypeHistoryMigrationResult.lift(
            try
                rustCallWithError(FfiConverterTypePlacesError.self) {
                    places_3413_PlacesConnection_places_history_import_from_ios(self.pointer,
                                                                                FfiConverterString.lower(dbPath),
                                                                                FfiConverterInt64.lower(lastSyncTimestamp), $0)
                }
        )
    }
}

private struct FfiConverterTypePlacesConnection: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PlacesConnection

    static func read(from buf: Reader) throws -> PlacesConnection {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: PlacesConnection, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PlacesConnection {
        return PlacesConnection(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: PlacesConnection) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol SqlInterruptHandleProtocol {
    func interrupt()
}

public class SqlInterruptHandle: SqlInterruptHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_places_3413_SqlInterruptHandle_object_free(pointer, $0) }
    }

    public func interrupt() {
        try!
            rustCall {
                places_3413_SqlInterruptHandle_interrupt(self.pointer, $0)
            }
    }
}

private struct FfiConverterTypeSqlInterruptHandle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SqlInterruptHandle

    static func read(from buf: Reader) throws -> SqlInterruptHandle {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: SqlInterruptHandle, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SqlInterruptHandle {
        return SqlInterruptHandle(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: SqlInterruptHandle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public struct BookmarkData {
    public var guid: Guid
    public var parentGuid: Guid
    public var position: UInt32
    public var dateAdded: PlacesTimestamp
    public var lastModified: PlacesTimestamp
    public var url: Url
    public var title: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: Guid, parentGuid: Guid, position: UInt32, dateAdded: PlacesTimestamp, lastModified: PlacesTimestamp, url: Url, title: String?) {
        self.guid = guid
        self.parentGuid = parentGuid
        self.position = position
        self.dateAdded = dateAdded
        self.lastModified = lastModified
        self.url = url
        self.title = title
    }
}

extension BookmarkData: Equatable, Hashable {
    public static func == (lhs: BookmarkData, rhs: BookmarkData) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(parentGuid)
        hasher.combine(position)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
        hasher.combine(url)
        hasher.combine(title)
    }
}

private struct FfiConverterTypeBookmarkData: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> BookmarkData {
        return try BookmarkData(
            guid: FfiConverterTypeGuid.read(from: buf),
            parentGuid: FfiConverterTypeGuid.read(from: buf),
            position: FfiConverterUInt32.read(from: buf),
            dateAdded: FfiConverterTypePlacesTimestamp.read(from: buf),
            lastModified: FfiConverterTypePlacesTimestamp.read(from: buf),
            url: FfiConverterTypeUrl.read(from: buf),
            title: FfiConverterOptionString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: BookmarkData, into buf: Writer) {
        FfiConverterTypeGuid.write(value.guid, into: buf)
        FfiConverterTypeGuid.write(value.parentGuid, into: buf)
        FfiConverterUInt32.write(value.position, into: buf)
        FfiConverterTypePlacesTimestamp.write(value.dateAdded, into: buf)
        FfiConverterTypePlacesTimestamp.write(value.lastModified, into: buf)
        FfiConverterTypeUrl.write(value.url, into: buf)
        FfiConverterOptionString.write(value.title, into: buf)
    }
}

public struct BookmarkFolder {
    public var guid: Guid
    public var dateAdded: PlacesTimestamp
    public var lastModified: PlacesTimestamp
    public var parentGuid: Guid?
    public var position: UInt32
    public var title: String?
    public var childGuids: [Guid]?
    public var childNodes: [BookmarkItem]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: Guid, dateAdded: PlacesTimestamp, lastModified: PlacesTimestamp, parentGuid: Guid?, position: UInt32, title: String?, childGuids: [Guid]?, childNodes: [BookmarkItem]?) {
        self.guid = guid
        self.dateAdded = dateAdded
        self.lastModified = lastModified
        self.parentGuid = parentGuid
        self.position = position
        self.title = title
        self.childGuids = childGuids
        self.childNodes = childNodes
    }
}

extension BookmarkFolder: Equatable, Hashable {
    public static func == (lhs: BookmarkFolder, rhs: BookmarkFolder) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.childGuids != rhs.childGuids {
            return false
        }
        if lhs.childNodes != rhs.childNodes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
        hasher.combine(parentGuid)
        hasher.combine(position)
        hasher.combine(title)
        hasher.combine(childGuids)
        hasher.combine(childNodes)
    }
}

private struct FfiConverterTypeBookmarkFolder: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> BookmarkFolder {
        return try BookmarkFolder(
            guid: FfiConverterTypeGuid.read(from: buf),
            dateAdded: FfiConverterTypePlacesTimestamp.read(from: buf),
            lastModified: FfiConverterTypePlacesTimestamp.read(from: buf),
            parentGuid: FfiConverterOptionTypeGuid.read(from: buf),
            position: FfiConverterUInt32.read(from: buf),
            title: FfiConverterOptionString.read(from: buf),
            childGuids: FfiConverterOptionSequenceTypeGuid.read(from: buf),
            childNodes: FfiConverterOptionSequenceTypeBookmarkItem.read(from: buf)
        )
    }

    fileprivate static func write(_ value: BookmarkFolder, into buf: Writer) {
        FfiConverterTypeGuid.write(value.guid, into: buf)
        FfiConverterTypePlacesTimestamp.write(value.dateAdded, into: buf)
        FfiConverterTypePlacesTimestamp.write(value.lastModified, into: buf)
        FfiConverterOptionTypeGuid.write(value.parentGuid, into: buf)
        FfiConverterUInt32.write(value.position, into: buf)
        FfiConverterOptionString.write(value.title, into: buf)
        FfiConverterOptionSequenceTypeGuid.write(value.childGuids, into: buf)
        FfiConverterOptionSequenceTypeBookmarkItem.write(value.childNodes, into: buf)
    }
}

public struct BookmarkSeparator {
    public var guid: Guid
    public var dateAdded: PlacesTimestamp
    public var lastModified: PlacesTimestamp
    public var parentGuid: Guid
    public var position: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: Guid, dateAdded: PlacesTimestamp, lastModified: PlacesTimestamp, parentGuid: Guid, position: UInt32) {
        self.guid = guid
        self.dateAdded = dateAdded
        self.lastModified = lastModified
        self.parentGuid = parentGuid
        self.position = position
    }
}

extension BookmarkSeparator: Equatable, Hashable {
    public static func == (lhs: BookmarkSeparator, rhs: BookmarkSeparator) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
        hasher.combine(parentGuid)
        hasher.combine(position)
    }
}

private struct FfiConverterTypeBookmarkSeparator: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> BookmarkSeparator {
        return try BookmarkSeparator(
            guid: FfiConverterTypeGuid.read(from: buf),
            dateAdded: FfiConverterTypePlacesTimestamp.read(from: buf),
            lastModified: FfiConverterTypePlacesTimestamp.read(from: buf),
            parentGuid: FfiConverterTypeGuid.read(from: buf),
            position: FfiConverterUInt32.read(from: buf)
        )
    }

    fileprivate static func write(_ value: BookmarkSeparator, into buf: Writer) {
        FfiConverterTypeGuid.write(value.guid, into: buf)
        FfiConverterTypePlacesTimestamp.write(value.dateAdded, into: buf)
        FfiConverterTypePlacesTimestamp.write(value.lastModified, into: buf)
        FfiConverterTypeGuid.write(value.parentGuid, into: buf)
        FfiConverterUInt32.write(value.position, into: buf)
    }
}

public struct BookmarkUpdateInfo {
    public var guid: Guid
    public var title: String?
    public var url: String?
    public var parentGuid: Guid?
    public var position: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: Guid, title: String?, url: String?, parentGuid: Guid?, position: UInt32?) {
        self.guid = guid
        self.title = title
        self.url = url
        self.parentGuid = parentGuid
        self.position = position
    }
}

extension BookmarkUpdateInfo: Equatable, Hashable {
    public static func == (lhs: BookmarkUpdateInfo, rhs: BookmarkUpdateInfo) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(title)
        hasher.combine(url)
        hasher.combine(parentGuid)
        hasher.combine(position)
    }
}

private struct FfiConverterTypeBookmarkUpdateInfo: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> BookmarkUpdateInfo {
        return try BookmarkUpdateInfo(
            guid: FfiConverterTypeGuid.read(from: buf),
            title: FfiConverterOptionString.read(from: buf),
            url: FfiConverterOptionString.read(from: buf),
            parentGuid: FfiConverterOptionTypeGuid.read(from: buf),
            position: FfiConverterOptionUInt32.read(from: buf)
        )
    }

    fileprivate static func write(_ value: BookmarkUpdateInfo, into buf: Writer) {
        FfiConverterTypeGuid.write(value.guid, into: buf)
        FfiConverterOptionString.write(value.title, into: buf)
        FfiConverterOptionString.write(value.url, into: buf)
        FfiConverterOptionTypeGuid.write(value.parentGuid, into: buf)
        FfiConverterOptionUInt32.write(value.position, into: buf)
    }
}

public struct Dummy {
    public var md: [HistoryMetadata]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(md: [HistoryMetadata]?) {
        self.md = md
    }
}

extension Dummy: Equatable, Hashable {
    public static func == (lhs: Dummy, rhs: Dummy) -> Bool {
        if lhs.md != rhs.md {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(md)
    }
}

private struct FfiConverterTypeDummy: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Dummy {
        return try Dummy(
            md: FfiConverterOptionSequenceTypeHistoryMetadata.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Dummy, into buf: Writer) {
        FfiConverterOptionSequenceTypeHistoryMetadata.write(value.md, into: buf)
    }
}

public struct HistoryHighlight {
    public var score: Double
    public var placeId: Int32
    public var url: String
    public var title: String?
    public var previewImageUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(score: Double, placeId: Int32, url: String, title: String?, previewImageUrl: String?) {
        self.score = score
        self.placeId = placeId
        self.url = url
        self.title = title
        self.previewImageUrl = previewImageUrl
    }
}

extension HistoryHighlight: Equatable, Hashable {
    public static func == (lhs: HistoryHighlight, rhs: HistoryHighlight) -> Bool {
        if lhs.score != rhs.score {
            return false
        }
        if lhs.placeId != rhs.placeId {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.previewImageUrl != rhs.previewImageUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(score)
        hasher.combine(placeId)
        hasher.combine(url)
        hasher.combine(title)
        hasher.combine(previewImageUrl)
    }
}

private struct FfiConverterTypeHistoryHighlight: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> HistoryHighlight {
        return try HistoryHighlight(
            score: FfiConverterDouble.read(from: buf),
            placeId: FfiConverterInt32.read(from: buf),
            url: FfiConverterString.read(from: buf),
            title: FfiConverterOptionString.read(from: buf),
            previewImageUrl: FfiConverterOptionString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: HistoryHighlight, into buf: Writer) {
        FfiConverterDouble.write(value.score, into: buf)
        FfiConverterInt32.write(value.placeId, into: buf)
        FfiConverterString.write(value.url, into: buf)
        FfiConverterOptionString.write(value.title, into: buf)
        FfiConverterOptionString.write(value.previewImageUrl, into: buf)
    }
}

public struct HistoryHighlightWeights {
    public var viewTime: Double
    public var frequency: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(viewTime: Double, frequency: Double) {
        self.viewTime = viewTime
        self.frequency = frequency
    }
}

extension HistoryHighlightWeights: Equatable, Hashable {
    public static func == (lhs: HistoryHighlightWeights, rhs: HistoryHighlightWeights) -> Bool {
        if lhs.viewTime != rhs.viewTime {
            return false
        }
        if lhs.frequency != rhs.frequency {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(viewTime)
        hasher.combine(frequency)
    }
}

private struct FfiConverterTypeHistoryHighlightWeights: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> HistoryHighlightWeights {
        return try HistoryHighlightWeights(
            viewTime: FfiConverterDouble.read(from: buf),
            frequency: FfiConverterDouble.read(from: buf)
        )
    }

    fileprivate static func write(_ value: HistoryHighlightWeights, into buf: Writer) {
        FfiConverterDouble.write(value.viewTime, into: buf)
        FfiConverterDouble.write(value.frequency, into: buf)
    }
}

public struct HistoryMetadata {
    public var url: String
    public var title: String?
    public var previewImageUrl: String?
    public var createdAt: Int64
    public var updatedAt: Int64
    public var totalViewTime: Int32
    public var searchTerm: String?
    public var documentType: DocumentType
    public var referrerUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, title: String?, previewImageUrl: String?, createdAt: Int64, updatedAt: Int64, totalViewTime: Int32, searchTerm: String?, documentType: DocumentType, referrerUrl: String?) {
        self.url = url
        self.title = title
        self.previewImageUrl = previewImageUrl
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.totalViewTime = totalViewTime
        self.searchTerm = searchTerm
        self.documentType = documentType
        self.referrerUrl = referrerUrl
    }
}

extension HistoryMetadata: Equatable, Hashable {
    public static func == (lhs: HistoryMetadata, rhs: HistoryMetadata) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.previewImageUrl != rhs.previewImageUrl {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.totalViewTime != rhs.totalViewTime {
            return false
        }
        if lhs.searchTerm != rhs.searchTerm {
            return false
        }
        if lhs.documentType != rhs.documentType {
            return false
        }
        if lhs.referrerUrl != rhs.referrerUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(title)
        hasher.combine(previewImageUrl)
        hasher.combine(createdAt)
        hasher.combine(updatedAt)
        hasher.combine(totalViewTime)
        hasher.combine(searchTerm)
        hasher.combine(documentType)
        hasher.combine(referrerUrl)
    }
}

private struct FfiConverterTypeHistoryMetadata: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> HistoryMetadata {
        return try HistoryMetadata(
            url: FfiConverterString.read(from: buf),
            title: FfiConverterOptionString.read(from: buf),
            previewImageUrl: FfiConverterOptionString.read(from: buf),
            createdAt: FfiConverterInt64.read(from: buf),
            updatedAt: FfiConverterInt64.read(from: buf),
            totalViewTime: FfiConverterInt32.read(from: buf),
            searchTerm: FfiConverterOptionString.read(from: buf),
            documentType: FfiConverterTypeDocumentType.read(from: buf),
            referrerUrl: FfiConverterOptionString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: HistoryMetadata, into buf: Writer) {
        FfiConverterString.write(value.url, into: buf)
        FfiConverterOptionString.write(value.title, into: buf)
        FfiConverterOptionString.write(value.previewImageUrl, into: buf)
        FfiConverterInt64.write(value.createdAt, into: buf)
        FfiConverterInt64.write(value.updatedAt, into: buf)
        FfiConverterInt32.write(value.totalViewTime, into: buf)
        FfiConverterOptionString.write(value.searchTerm, into: buf)
        FfiConverterTypeDocumentType.write(value.documentType, into: buf)
        FfiConverterOptionString.write(value.referrerUrl, into: buf)
    }
}

public struct HistoryMetadataObservation {
    public var url: String
    public var referrerUrl: String?
    public var searchTerm: String?
    public var viewTime: Int32?
    public var documentType: DocumentType?
    public var title: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, referrerUrl: String? = nil, searchTerm: String? = nil, viewTime: Int32? = nil, documentType: DocumentType? = nil, title: String? = nil) {
        self.url = url
        self.referrerUrl = referrerUrl
        self.searchTerm = searchTerm
        self.viewTime = viewTime
        self.documentType = documentType
        self.title = title
    }
}

extension HistoryMetadataObservation: Equatable, Hashable {
    public static func == (lhs: HistoryMetadataObservation, rhs: HistoryMetadataObservation) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.referrerUrl != rhs.referrerUrl {
            return false
        }
        if lhs.searchTerm != rhs.searchTerm {
            return false
        }
        if lhs.viewTime != rhs.viewTime {
            return false
        }
        if lhs.documentType != rhs.documentType {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(referrerUrl)
        hasher.combine(searchTerm)
        hasher.combine(viewTime)
        hasher.combine(documentType)
        hasher.combine(title)
    }
}

private struct FfiConverterTypeHistoryMetadataObservation: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> HistoryMetadataObservation {
        return try HistoryMetadataObservation(
            url: FfiConverterString.read(from: buf),
            referrerUrl: FfiConverterOptionString.read(from: buf),
            searchTerm: FfiConverterOptionString.read(from: buf),
            viewTime: FfiConverterOptionInt32.read(from: buf),
            documentType: FfiConverterOptionTypeDocumentType.read(from: buf),
            title: FfiConverterOptionString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: HistoryMetadataObservation, into buf: Writer) {
        FfiConverterString.write(value.url, into: buf)
        FfiConverterOptionString.write(value.referrerUrl, into: buf)
        FfiConverterOptionString.write(value.searchTerm, into: buf)
        FfiConverterOptionInt32.write(value.viewTime, into: buf)
        FfiConverterOptionTypeDocumentType.write(value.documentType, into: buf)
        FfiConverterOptionString.write(value.title, into: buf)
    }
}

public struct HistoryMigrationResult {
    public var numTotal: UInt32
    public var numSucceeded: UInt32
    public var numFailed: UInt32
    public var totalDuration: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numTotal: UInt32, numSucceeded: UInt32, numFailed: UInt32, totalDuration: UInt64) {
        self.numTotal = numTotal
        self.numSucceeded = numSucceeded
        self.numFailed = numFailed
        self.totalDuration = totalDuration
    }
}

extension HistoryMigrationResult: Equatable, Hashable {
    public static func == (lhs: HistoryMigrationResult, rhs: HistoryMigrationResult) -> Bool {
        if lhs.numTotal != rhs.numTotal {
            return false
        }
        if lhs.numSucceeded != rhs.numSucceeded {
            return false
        }
        if lhs.numFailed != rhs.numFailed {
            return false
        }
        if lhs.totalDuration != rhs.totalDuration {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numTotal)
        hasher.combine(numSucceeded)
        hasher.combine(numFailed)
        hasher.combine(totalDuration)
    }
}

private struct FfiConverterTypeHistoryMigrationResult: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> HistoryMigrationResult {
        return try HistoryMigrationResult(
            numTotal: FfiConverterUInt32.read(from: buf),
            numSucceeded: FfiConverterUInt32.read(from: buf),
            numFailed: FfiConverterUInt32.read(from: buf),
            totalDuration: FfiConverterUInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: HistoryMigrationResult, into buf: Writer) {
        FfiConverterUInt32.write(value.numTotal, into: buf)
        FfiConverterUInt32.write(value.numSucceeded, into: buf)
        FfiConverterUInt32.write(value.numFailed, into: buf)
        FfiConverterUInt64.write(value.totalDuration, into: buf)
    }
}

public struct HistoryVisitInfo {
    public var url: Url
    public var title: String?
    public var timestamp: PlacesTimestamp
    public var visitType: VisitTransition
    public var isHidden: Bool
    public var previewImageUrl: Url?
    public var isRemote: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: Url, title: String?, timestamp: PlacesTimestamp, visitType: VisitTransition, isHidden: Bool, previewImageUrl: Url?, isRemote: Bool) {
        self.url = url
        self.title = title
        self.timestamp = timestamp
        self.visitType = visitType
        self.isHidden = isHidden
        self.previewImageUrl = previewImageUrl
        self.isRemote = isRemote
    }
}

extension HistoryVisitInfo: Equatable, Hashable {
    public static func == (lhs: HistoryVisitInfo, rhs: HistoryVisitInfo) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.visitType != rhs.visitType {
            return false
        }
        if lhs.isHidden != rhs.isHidden {
            return false
        }
        if lhs.previewImageUrl != rhs.previewImageUrl {
            return false
        }
        if lhs.isRemote != rhs.isRemote {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(title)
        hasher.combine(timestamp)
        hasher.combine(visitType)
        hasher.combine(isHidden)
        hasher.combine(previewImageUrl)
        hasher.combine(isRemote)
    }
}

private struct FfiConverterTypeHistoryVisitInfo: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> HistoryVisitInfo {
        return try HistoryVisitInfo(
            url: FfiConverterTypeUrl.read(from: buf),
            title: FfiConverterOptionString.read(from: buf),
            timestamp: FfiConverterTypePlacesTimestamp.read(from: buf),
            visitType: FfiConverterTypeVisitTransition.read(from: buf),
            isHidden: FfiConverterBool.read(from: buf),
            previewImageUrl: FfiConverterOptionTypeUrl.read(from: buf),
            isRemote: FfiConverterBool.read(from: buf)
        )
    }

    fileprivate static func write(_ value: HistoryVisitInfo, into buf: Writer) {
        FfiConverterTypeUrl.write(value.url, into: buf)
        FfiConverterOptionString.write(value.title, into: buf)
        FfiConverterTypePlacesTimestamp.write(value.timestamp, into: buf)
        FfiConverterTypeVisitTransition.write(value.visitType, into: buf)
        FfiConverterBool.write(value.isHidden, into: buf)
        FfiConverterOptionTypeUrl.write(value.previewImageUrl, into: buf)
        FfiConverterBool.write(value.isRemote, into: buf)
    }
}

public struct HistoryVisitInfosWithBound {
    public var infos: [HistoryVisitInfo]
    public var bound: Int64
    public var offset: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(infos: [HistoryVisitInfo], bound: Int64, offset: Int64) {
        self.infos = infos
        self.bound = bound
        self.offset = offset
    }
}

extension HistoryVisitInfosWithBound: Equatable, Hashable {
    public static func == (lhs: HistoryVisitInfosWithBound, rhs: HistoryVisitInfosWithBound) -> Bool {
        if lhs.infos != rhs.infos {
            return false
        }
        if lhs.bound != rhs.bound {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(infos)
        hasher.combine(bound)
        hasher.combine(offset)
    }
}

private struct FfiConverterTypeHistoryVisitInfosWithBound: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> HistoryVisitInfosWithBound {
        return try HistoryVisitInfosWithBound(
            infos: FfiConverterSequenceTypeHistoryVisitInfo.read(from: buf),
            bound: FfiConverterInt64.read(from: buf),
            offset: FfiConverterInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: HistoryVisitInfosWithBound, into buf: Writer) {
        FfiConverterSequenceTypeHistoryVisitInfo.write(value.infos, into: buf)
        FfiConverterInt64.write(value.bound, into: buf)
        FfiConverterInt64.write(value.offset, into: buf)
    }
}

public struct InsertableBookmark {
    public var guid: Guid?
    public var parentGuid: Guid
    public var position: BookmarkPosition
    public var dateAdded: PlacesTimestamp?
    public var lastModified: PlacesTimestamp?
    public var url: Url
    public var title: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: Guid? = nil, parentGuid: Guid, position: BookmarkPosition, dateAdded: PlacesTimestamp? = nil, lastModified: PlacesTimestamp? = nil, url: Url, title: String? = nil) {
        self.guid = guid
        self.parentGuid = parentGuid
        self.position = position
        self.dateAdded = dateAdded
        self.lastModified = lastModified
        self.url = url
        self.title = title
    }
}

extension InsertableBookmark: Equatable, Hashable {
    public static func == (lhs: InsertableBookmark, rhs: InsertableBookmark) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(parentGuid)
        hasher.combine(position)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
        hasher.combine(url)
        hasher.combine(title)
    }
}

private struct FfiConverterTypeInsertableBookmark: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> InsertableBookmark {
        return try InsertableBookmark(
            guid: FfiConverterOptionTypeGuid.read(from: buf),
            parentGuid: FfiConverterTypeGuid.read(from: buf),
            position: FfiConverterTypeBookmarkPosition.read(from: buf),
            dateAdded: FfiConverterOptionTypePlacesTimestamp.read(from: buf),
            lastModified: FfiConverterOptionTypePlacesTimestamp.read(from: buf),
            url: FfiConverterTypeUrl.read(from: buf),
            title: FfiConverterOptionString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: InsertableBookmark, into buf: Writer) {
        FfiConverterOptionTypeGuid.write(value.guid, into: buf)
        FfiConverterTypeGuid.write(value.parentGuid, into: buf)
        FfiConverterTypeBookmarkPosition.write(value.position, into: buf)
        FfiConverterOptionTypePlacesTimestamp.write(value.dateAdded, into: buf)
        FfiConverterOptionTypePlacesTimestamp.write(value.lastModified, into: buf)
        FfiConverterTypeUrl.write(value.url, into: buf)
        FfiConverterOptionString.write(value.title, into: buf)
    }
}

public struct InsertableBookmarkFolder {
    public var guid: Guid?
    public var parentGuid: Guid
    public var position: BookmarkPosition
    public var dateAdded: PlacesTimestamp?
    public var lastModified: PlacesTimestamp?
    public var title: String?
    public var children: [InsertableBookmarkItem]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: Guid? = nil, parentGuid: Guid, position: BookmarkPosition, dateAdded: PlacesTimestamp? = nil, lastModified: PlacesTimestamp? = nil, title: String? = nil, children: [InsertableBookmarkItem]) {
        self.guid = guid
        self.parentGuid = parentGuid
        self.position = position
        self.dateAdded = dateAdded
        self.lastModified = lastModified
        self.title = title
        self.children = children
    }
}

extension InsertableBookmarkFolder: Equatable, Hashable {
    public static func == (lhs: InsertableBookmarkFolder, rhs: InsertableBookmarkFolder) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.children != rhs.children {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(parentGuid)
        hasher.combine(position)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
        hasher.combine(title)
        hasher.combine(children)
    }
}

private struct FfiConverterTypeInsertableBookmarkFolder: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> InsertableBookmarkFolder {
        return try InsertableBookmarkFolder(
            guid: FfiConverterOptionTypeGuid.read(from: buf),
            parentGuid: FfiConverterTypeGuid.read(from: buf),
            position: FfiConverterTypeBookmarkPosition.read(from: buf),
            dateAdded: FfiConverterOptionTypePlacesTimestamp.read(from: buf),
            lastModified: FfiConverterOptionTypePlacesTimestamp.read(from: buf),
            title: FfiConverterOptionString.read(from: buf),
            children: FfiConverterSequenceTypeInsertableBookmarkItem.read(from: buf)
        )
    }

    fileprivate static func write(_ value: InsertableBookmarkFolder, into buf: Writer) {
        FfiConverterOptionTypeGuid.write(value.guid, into: buf)
        FfiConverterTypeGuid.write(value.parentGuid, into: buf)
        FfiConverterTypeBookmarkPosition.write(value.position, into: buf)
        FfiConverterOptionTypePlacesTimestamp.write(value.dateAdded, into: buf)
        FfiConverterOptionTypePlacesTimestamp.write(value.lastModified, into: buf)
        FfiConverterOptionString.write(value.title, into: buf)
        FfiConverterSequenceTypeInsertableBookmarkItem.write(value.children, into: buf)
    }
}

public struct InsertableBookmarkSeparator {
    public var guid: Guid?
    public var parentGuid: Guid
    public var position: BookmarkPosition
    public var dateAdded: PlacesTimestamp?
    public var lastModified: PlacesTimestamp?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(guid: Guid? = nil, parentGuid: Guid, position: BookmarkPosition, dateAdded: PlacesTimestamp? = nil, lastModified: PlacesTimestamp? = nil) {
        self.guid = guid
        self.parentGuid = parentGuid
        self.position = position
        self.dateAdded = dateAdded
        self.lastModified = lastModified
    }
}

extension InsertableBookmarkSeparator: Equatable, Hashable {
    public static func == (lhs: InsertableBookmarkSeparator, rhs: InsertableBookmarkSeparator) -> Bool {
        if lhs.guid != rhs.guid {
            return false
        }
        if lhs.parentGuid != rhs.parentGuid {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.dateAdded != rhs.dateAdded {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(guid)
        hasher.combine(parentGuid)
        hasher.combine(position)
        hasher.combine(dateAdded)
        hasher.combine(lastModified)
    }
}

private struct FfiConverterTypeInsertableBookmarkSeparator: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> InsertableBookmarkSeparator {
        return try InsertableBookmarkSeparator(
            guid: FfiConverterOptionTypeGuid.read(from: buf),
            parentGuid: FfiConverterTypeGuid.read(from: buf),
            position: FfiConverterTypeBookmarkPosition.read(from: buf),
            dateAdded: FfiConverterOptionTypePlacesTimestamp.read(from: buf),
            lastModified: FfiConverterOptionTypePlacesTimestamp.read(from: buf)
        )
    }

    fileprivate static func write(_ value: InsertableBookmarkSeparator, into buf: Writer) {
        FfiConverterOptionTypeGuid.write(value.guid, into: buf)
        FfiConverterTypeGuid.write(value.parentGuid, into: buf)
        FfiConverterTypeBookmarkPosition.write(value.position, into: buf)
        FfiConverterOptionTypePlacesTimestamp.write(value.dateAdded, into: buf)
        FfiConverterOptionTypePlacesTimestamp.write(value.lastModified, into: buf)
    }
}

public struct RunMaintenanceMetrics {
    public var prunedVisits: Bool
    public var dbSizeBefore: UInt32
    public var dbSizeAfter: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(prunedVisits: Bool, dbSizeBefore: UInt32, dbSizeAfter: UInt32) {
        self.prunedVisits = prunedVisits
        self.dbSizeBefore = dbSizeBefore
        self.dbSizeAfter = dbSizeAfter
    }
}

extension RunMaintenanceMetrics: Equatable, Hashable {
    public static func == (lhs: RunMaintenanceMetrics, rhs: RunMaintenanceMetrics) -> Bool {
        if lhs.prunedVisits != rhs.prunedVisits {
            return false
        }
        if lhs.dbSizeBefore != rhs.dbSizeBefore {
            return false
        }
        if lhs.dbSizeAfter != rhs.dbSizeAfter {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(prunedVisits)
        hasher.combine(dbSizeBefore)
        hasher.combine(dbSizeAfter)
    }
}

private struct FfiConverterTypeRunMaintenanceMetrics: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> RunMaintenanceMetrics {
        return try RunMaintenanceMetrics(
            prunedVisits: FfiConverterBool.read(from: buf),
            dbSizeBefore: FfiConverterUInt32.read(from: buf),
            dbSizeAfter: FfiConverterUInt32.read(from: buf)
        )
    }

    fileprivate static func write(_ value: RunMaintenanceMetrics, into buf: Writer) {
        FfiConverterBool.write(value.prunedVisits, into: buf)
        FfiConverterUInt32.write(value.dbSizeBefore, into: buf)
        FfiConverterUInt32.write(value.dbSizeAfter, into: buf)
    }
}

public struct SearchResult {
    public var url: Url
    public var title: String
    public var frecency: Int64
    public var reasons: [MatchReason]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: Url, title: String, frecency: Int64, reasons: [MatchReason]) {
        self.url = url
        self.title = title
        self.frecency = frecency
        self.reasons = reasons
    }
}

extension SearchResult: Equatable, Hashable {
    public static func == (lhs: SearchResult, rhs: SearchResult) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.frecency != rhs.frecency {
            return false
        }
        if lhs.reasons != rhs.reasons {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(title)
        hasher.combine(frecency)
        hasher.combine(reasons)
    }
}

private struct FfiConverterTypeSearchResult: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> SearchResult {
        return try SearchResult(
            url: FfiConverterTypeUrl.read(from: buf),
            title: FfiConverterString.read(from: buf),
            frecency: FfiConverterInt64.read(from: buf),
            reasons: FfiConverterSequenceTypeMatchReason.read(from: buf)
        )
    }

    fileprivate static func write(_ value: SearchResult, into buf: Writer) {
        FfiConverterTypeUrl.write(value.url, into: buf)
        FfiConverterString.write(value.title, into: buf)
        FfiConverterInt64.write(value.frecency, into: buf)
        FfiConverterSequenceTypeMatchReason.write(value.reasons, into: buf)
    }
}

public struct TopFrecentSiteInfo {
    public var url: Url
    public var title: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: Url, title: String?) {
        self.url = url
        self.title = title
    }
}

extension TopFrecentSiteInfo: Equatable, Hashable {
    public static func == (lhs: TopFrecentSiteInfo, rhs: TopFrecentSiteInfo) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(title)
    }
}

private struct FfiConverterTypeTopFrecentSiteInfo: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> TopFrecentSiteInfo {
        return try TopFrecentSiteInfo(
            url: FfiConverterTypeUrl.read(from: buf),
            title: FfiConverterOptionString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: TopFrecentSiteInfo, into buf: Writer) {
        FfiConverterTypeUrl.write(value.url, into: buf)
        FfiConverterOptionString.write(value.title, into: buf)
    }
}

public struct VisitObservation {
    public var url: Url
    public var title: String?
    public var visitType: VisitTransition?
    public var isError: Bool?
    public var isRedirectSource: Bool?
    public var isPermanentRedirectSource: Bool?
    public var at: PlacesTimestamp?
    public var referrer: Url?
    public var isRemote: Bool?
    public var previewImageUrl: Url?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: Url, title: String? = nil, visitType: VisitTransition?, isError: Bool? = nil, isRedirectSource: Bool? = nil, isPermanentRedirectSource: Bool? = nil, at: PlacesTimestamp? = nil, referrer: Url? = nil, isRemote: Bool? = nil, previewImageUrl: Url? = nil) {
        self.url = url
        self.title = title
        self.visitType = visitType
        self.isError = isError
        self.isRedirectSource = isRedirectSource
        self.isPermanentRedirectSource = isPermanentRedirectSource
        self.at = at
        self.referrer = referrer
        self.isRemote = isRemote
        self.previewImageUrl = previewImageUrl
    }
}

extension VisitObservation: Equatable, Hashable {
    public static func == (lhs: VisitObservation, rhs: VisitObservation) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.visitType != rhs.visitType {
            return false
        }
        if lhs.isError != rhs.isError {
            return false
        }
        if lhs.isRedirectSource != rhs.isRedirectSource {
            return false
        }
        if lhs.isPermanentRedirectSource != rhs.isPermanentRedirectSource {
            return false
        }
        if lhs.at != rhs.at {
            return false
        }
        if lhs.referrer != rhs.referrer {
            return false
        }
        if lhs.isRemote != rhs.isRemote {
            return false
        }
        if lhs.previewImageUrl != rhs.previewImageUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(title)
        hasher.combine(visitType)
        hasher.combine(isError)
        hasher.combine(isRedirectSource)
        hasher.combine(isPermanentRedirectSource)
        hasher.combine(at)
        hasher.combine(referrer)
        hasher.combine(isRemote)
        hasher.combine(previewImageUrl)
    }
}

private struct FfiConverterTypeVisitObservation: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> VisitObservation {
        return try VisitObservation(
            url: FfiConverterTypeUrl.read(from: buf),
            title: FfiConverterOptionString.read(from: buf),
            visitType: FfiConverterOptionTypeVisitTransition.read(from: buf),
            isError: FfiConverterOptionBool.read(from: buf),
            isRedirectSource: FfiConverterOptionBool.read(from: buf),
            isPermanentRedirectSource: FfiConverterOptionBool.read(from: buf),
            at: FfiConverterOptionTypePlacesTimestamp.read(from: buf),
            referrer: FfiConverterOptionTypeUrl.read(from: buf),
            isRemote: FfiConverterOptionBool.read(from: buf),
            previewImageUrl: FfiConverterOptionTypeUrl.read(from: buf)
        )
    }

    fileprivate static func write(_ value: VisitObservation, into buf: Writer) {
        FfiConverterTypeUrl.write(value.url, into: buf)
        FfiConverterOptionString.write(value.title, into: buf)
        FfiConverterOptionTypeVisitTransition.write(value.visitType, into: buf)
        FfiConverterOptionBool.write(value.isError, into: buf)
        FfiConverterOptionBool.write(value.isRedirectSource, into: buf)
        FfiConverterOptionBool.write(value.isPermanentRedirectSource, into: buf)
        FfiConverterOptionTypePlacesTimestamp.write(value.at, into: buf)
        FfiConverterOptionTypeUrl.write(value.referrer, into: buf)
        FfiConverterOptionBool.write(value.isRemote, into: buf)
        FfiConverterOptionTypeUrl.write(value.previewImageUrl, into: buf)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BookmarkItem {
    case bookmark(b: BookmarkData)
    case separator(s: BookmarkSeparator)
    case folder(f: BookmarkFolder)
}

private struct FfiConverterTypeBookmarkItem: FfiConverterRustBuffer {
    typealias SwiftType = BookmarkItem

    static func read(from buf: Reader) throws -> BookmarkItem {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .bookmark(
                b: try FfiConverterTypeBookmarkData.read(from: buf)
            )

        case 2: return .separator(
                s: try FfiConverterTypeBookmarkSeparator.read(from: buf)
            )

        case 3: return .folder(
                f: try FfiConverterTypeBookmarkFolder.read(from: buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: BookmarkItem, into buf: Writer) {
        switch value {
        case let .bookmark(b):
            buf.writeInt(Int32(1))
            FfiConverterTypeBookmarkData.write(b, into: buf)

        case let .separator(s):
            buf.writeInt(Int32(2))
            FfiConverterTypeBookmarkSeparator.write(s, into: buf)

        case let .folder(f):
            buf.writeInt(Int32(3))
            FfiConverterTypeBookmarkFolder.write(f, into: buf)
        }
    }
}

extension BookmarkItem: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BookmarkPosition {
    case specific(pos: UInt32)
    case append
}

private struct FfiConverterTypeBookmarkPosition: FfiConverterRustBuffer {
    typealias SwiftType = BookmarkPosition

    static func read(from buf: Reader) throws -> BookmarkPosition {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .specific(
                pos: try FfiConverterUInt32.read(from: buf)
            )

        case 2: return .append

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: BookmarkPosition, into buf: Writer) {
        switch value {
        case let .specific(pos):
            buf.writeInt(Int32(1))
            FfiConverterUInt32.write(pos, into: buf)

        case .append:
            buf.writeInt(Int32(2))
        }
    }
}

extension BookmarkPosition: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ConnectionType {
    case readOnly
    case readWrite
    case sync
}

private struct FfiConverterTypeConnectionType: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionType

    static func read(from buf: Reader) throws -> ConnectionType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .readOnly

        case 2: return .readWrite

        case 3: return .sync

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: ConnectionType, into buf: Writer) {
        switch value {
        case .readOnly:
            buf.writeInt(Int32(1))

        case .readWrite:
            buf.writeInt(Int32(2))

        case .sync:
            buf.writeInt(Int32(3))
        }
    }
}

extension ConnectionType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DocumentType {
    case regular
    case media
}

private struct FfiConverterTypeDocumentType: FfiConverterRustBuffer {
    typealias SwiftType = DocumentType

    static func read(from buf: Reader) throws -> DocumentType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .regular

        case 2: return .media

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: DocumentType, into buf: Writer) {
        switch value {
        case .regular:
            buf.writeInt(Int32(1))

        case .media:
            buf.writeInt(Int32(2))
        }
    }
}

extension DocumentType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FrecencyThresholdOption {
    case none
    case skipOneTimePages
}

private struct FfiConverterTypeFrecencyThresholdOption: FfiConverterRustBuffer {
    typealias SwiftType = FrecencyThresholdOption

    static func read(from buf: Reader) throws -> FrecencyThresholdOption {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .none

        case 2: return .skipOneTimePages

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: FrecencyThresholdOption, into buf: Writer) {
        switch value {
        case .none:
            buf.writeInt(Int32(1))

        case .skipOneTimePages:
            buf.writeInt(Int32(2))
        }
    }
}

extension FrecencyThresholdOption: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum InsertableBookmarkItem {
    case bookmark(b: InsertableBookmark)
    case folder(f: InsertableBookmarkFolder)
    case separator(s: InsertableBookmarkSeparator)
}

private struct FfiConverterTypeInsertableBookmarkItem: FfiConverterRustBuffer {
    typealias SwiftType = InsertableBookmarkItem

    static func read(from buf: Reader) throws -> InsertableBookmarkItem {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .bookmark(
                b: try FfiConverterTypeInsertableBookmark.read(from: buf)
            )

        case 2: return .folder(
                f: try FfiConverterTypeInsertableBookmarkFolder.read(from: buf)
            )

        case 3: return .separator(
                s: try FfiConverterTypeInsertableBookmarkSeparator.read(from: buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: InsertableBookmarkItem, into buf: Writer) {
        switch value {
        case let .bookmark(b):
            buf.writeInt(Int32(1))
            FfiConverterTypeInsertableBookmark.write(b, into: buf)

        case let .folder(f):
            buf.writeInt(Int32(2))
            FfiConverterTypeInsertableBookmarkFolder.write(f, into: buf)

        case let .separator(s):
            buf.writeInt(Int32(3))
            FfiConverterTypeInsertableBookmarkSeparator.write(s, into: buf)
        }
    }
}

extension InsertableBookmarkItem: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MatchReason {
    case keyword
    case origin
    case urlMatch
    case previousUse
    case bookmark
    case tags
}

private struct FfiConverterTypeMatchReason: FfiConverterRustBuffer {
    typealias SwiftType = MatchReason

    static func read(from buf: Reader) throws -> MatchReason {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .keyword

        case 2: return .origin

        case 3: return .urlMatch

        case 4: return .previousUse

        case 5: return .bookmark

        case 6: return .tags

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: MatchReason, into buf: Writer) {
        switch value {
        case .keyword:
            buf.writeInt(Int32(1))

        case .origin:
            buf.writeInt(Int32(2))

        case .urlMatch:
            buf.writeInt(Int32(3))

        case .previousUse:
            buf.writeInt(Int32(4))

        case .bookmark:
            buf.writeInt(Int32(5))

        case .tags:
            buf.writeInt(Int32(6))
        }
    }
}

extension MatchReason: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum VisitTransition {
    case link
    case typed
    case bookmark
    case embed
    case redirectPermanent
    case redirectTemporary
    case download
    case framedLink
    case reload
}

private struct FfiConverterTypeVisitTransition: FfiConverterRustBuffer {
    typealias SwiftType = VisitTransition

    static func read(from buf: Reader) throws -> VisitTransition {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .link

        case 2: return .typed

        case 3: return .bookmark

        case 4: return .embed

        case 5: return .redirectPermanent

        case 6: return .redirectTemporary

        case 7: return .download

        case 8: return .framedLink

        case 9: return .reload

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: VisitTransition, into buf: Writer) {
        switch value {
        case .link:
            buf.writeInt(Int32(1))

        case .typed:
            buf.writeInt(Int32(2))

        case .bookmark:
            buf.writeInt(Int32(3))

        case .embed:
            buf.writeInt(Int32(4))

        case .redirectPermanent:
            buf.writeInt(Int32(5))

        case .redirectTemporary:
            buf.writeInt(Int32(6))

        case .download:
            buf.writeInt(Int32(7))

        case .framedLink:
            buf.writeInt(Int32(8))

        case .reload:
            buf.writeInt(Int32(9))
        }
    }
}

extension VisitTransition: Equatable, Hashable {}

public enum PlacesError {
    // Simple error enums only carry a message
    case UnexpectedPlacesException(message: String)

    // Simple error enums only carry a message
    case UrlParseFailed(message: String)

    // Simple error enums only carry a message
    case JsonParseFailed(message: String)

    // Simple error enums only carry a message
    case PlacesConnectionBusy(message: String)

    // Simple error enums only carry a message
    case OperationInterrupted(message: String)

    // Simple error enums only carry a message
    case BookmarksCorruption(message: String)

    // Simple error enums only carry a message
    case InvalidParent(message: String)

    // Simple error enums only carry a message
    case UnknownBookmarkItem(message: String)

    // Simple error enums only carry a message
    case UrlTooLong(message: String)

    // Simple error enums only carry a message
    case InvalidBookmarkUpdate(message: String)

    // Simple error enums only carry a message
    case CannotUpdateRoot(message: String)

    // Simple error enums only carry a message
    case InternalError(message: String)
}

private struct FfiConverterTypePlacesError: FfiConverterRustBuffer {
    typealias SwiftType = PlacesError

    static func read(from buf: Reader) throws -> PlacesError {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .UnexpectedPlacesException(
                message: try FfiConverterString.read(from: buf)
            )

        case 2: return .UrlParseFailed(
                message: try FfiConverterString.read(from: buf)
            )

        case 3: return .JsonParseFailed(
                message: try FfiConverterString.read(from: buf)
            )

        case 4: return .PlacesConnectionBusy(
                message: try FfiConverterString.read(from: buf)
            )

        case 5: return .OperationInterrupted(
                message: try FfiConverterString.read(from: buf)
            )

        case 6: return .BookmarksCorruption(
                message: try FfiConverterString.read(from: buf)
            )

        case 7: return .InvalidParent(
                message: try FfiConverterString.read(from: buf)
            )

        case 8: return .UnknownBookmarkItem(
                message: try FfiConverterString.read(from: buf)
            )

        case 9: return .UrlTooLong(
                message: try FfiConverterString.read(from: buf)
            )

        case 10: return .InvalidBookmarkUpdate(
                message: try FfiConverterString.read(from: buf)
            )

        case 11: return .CannotUpdateRoot(
                message: try FfiConverterString.read(from: buf)
            )

        case 12: return .InternalError(
                message: try FfiConverterString.read(from: buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: PlacesError, into buf: Writer) {
        switch value {
        case let .UnexpectedPlacesException(message):
            buf.writeInt(Int32(1))
            FfiConverterString.write(message, into: buf)
        case let .UrlParseFailed(message):
            buf.writeInt(Int32(2))
            FfiConverterString.write(message, into: buf)
        case let .JsonParseFailed(message):
            buf.writeInt(Int32(3))
            FfiConverterString.write(message, into: buf)
        case let .PlacesConnectionBusy(message):
            buf.writeInt(Int32(4))
            FfiConverterString.write(message, into: buf)
        case let .OperationInterrupted(message):
            buf.writeInt(Int32(5))
            FfiConverterString.write(message, into: buf)
        case let .BookmarksCorruption(message):
            buf.writeInt(Int32(6))
            FfiConverterString.write(message, into: buf)
        case let .InvalidParent(message):
            buf.writeInt(Int32(7))
            FfiConverterString.write(message, into: buf)
        case let .UnknownBookmarkItem(message):
            buf.writeInt(Int32(8))
            FfiConverterString.write(message, into: buf)
        case let .UrlTooLong(message):
            buf.writeInt(Int32(9))
            FfiConverterString.write(message, into: buf)
        case let .InvalidBookmarkUpdate(message):
            buf.writeInt(Int32(10))
            FfiConverterString.write(message, into: buf)
        case let .CannotUpdateRoot(message):
            buf.writeInt(Int32(11))
            FfiConverterString.write(message, into: buf)
        case let .InternalError(message):
            buf.writeInt(Int32(12))
            FfiConverterString.write(message, into: buf)
        }
    }
}

extension PlacesError: Equatable, Hashable {}

extension PlacesError: Error {}

private struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterUInt32.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterInt32.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterBool.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterString.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeHistoryMetadata: FfiConverterRustBuffer {
    typealias SwiftType = HistoryMetadata?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeHistoryMetadata.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHistoryMetadata.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeBookmarkItem: FfiConverterRustBuffer {
    typealias SwiftType = BookmarkItem?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeBookmarkItem.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBookmarkItem.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDocumentType: FfiConverterRustBuffer {
    typealias SwiftType = DocumentType?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeDocumentType.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDocumentType.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeVisitTransition: FfiConverterRustBuffer {
    typealias SwiftType = VisitTransition?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeVisitTransition.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVisitTransition.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeHistoryMetadata: FfiConverterRustBuffer {
    typealias SwiftType = [HistoryMetadata]?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterSequenceTypeHistoryMetadata.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeHistoryMetadata.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeBookmarkItem: FfiConverterRustBuffer {
    typealias SwiftType = [BookmarkItem]?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterSequenceTypeBookmarkItem.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeBookmarkItem.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeGuid: FfiConverterRustBuffer {
    typealias SwiftType = [Guid]?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterSequenceTypeGuid.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeGuid.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeGuid: FfiConverterRustBuffer {
    typealias SwiftType = Guid?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeGuid.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeGuid.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePlacesTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = PlacesTimestamp?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypePlacesTimestamp.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePlacesTimestamp.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeUrl: FfiConverterRustBuffer {
    typealias SwiftType = Url?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeUrl.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUrl.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceBool: FfiConverterRustBuffer {
    typealias SwiftType = [Bool]

    static func write(_ value: [Bool], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterBool.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [Bool] {
        let len: Int32 = try buf.readInt()
        var seq = [Bool]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterBool.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    static func write(_ value: [String], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterString.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [String] {
        let len: Int32 = try buf.readInt()
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHistoryHighlight: FfiConverterRustBuffer {
    typealias SwiftType = [HistoryHighlight]

    static func write(_ value: [HistoryHighlight], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeHistoryHighlight.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [HistoryHighlight] {
        let len: Int32 = try buf.readInt()
        var seq = [HistoryHighlight]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHistoryHighlight.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHistoryMetadata: FfiConverterRustBuffer {
    typealias SwiftType = [HistoryMetadata]

    static func write(_ value: [HistoryMetadata], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeHistoryMetadata.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [HistoryMetadata] {
        let len: Int32 = try buf.readInt()
        var seq = [HistoryMetadata]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHistoryMetadata.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHistoryVisitInfo: FfiConverterRustBuffer {
    typealias SwiftType = [HistoryVisitInfo]

    static func write(_ value: [HistoryVisitInfo], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeHistoryVisitInfo.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [HistoryVisitInfo] {
        let len: Int32 = try buf.readInt()
        var seq = [HistoryVisitInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHistoryVisitInfo.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSearchResult: FfiConverterRustBuffer {
    typealias SwiftType = [SearchResult]

    static func write(_ value: [SearchResult], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeSearchResult.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [SearchResult] {
        let len: Int32 = try buf.readInt()
        var seq = [SearchResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSearchResult.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTopFrecentSiteInfo: FfiConverterRustBuffer {
    typealias SwiftType = [TopFrecentSiteInfo]

    static func write(_ value: [TopFrecentSiteInfo], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeTopFrecentSiteInfo.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [TopFrecentSiteInfo] {
        let len: Int32 = try buf.readInt()
        var seq = [TopFrecentSiteInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTopFrecentSiteInfo.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBookmarkItem: FfiConverterRustBuffer {
    typealias SwiftType = [BookmarkItem]

    static func write(_ value: [BookmarkItem], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeBookmarkItem.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [BookmarkItem] {
        let len: Int32 = try buf.readInt()
        var seq = [BookmarkItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBookmarkItem.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeInsertableBookmarkItem: FfiConverterRustBuffer {
    typealias SwiftType = [InsertableBookmarkItem]

    static func write(_ value: [InsertableBookmarkItem], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeInsertableBookmarkItem.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [InsertableBookmarkItem] {
        let len: Int32 = try buf.readInt()
        var seq = [InsertableBookmarkItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeInsertableBookmarkItem.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeMatchReason: FfiConverterRustBuffer {
    typealias SwiftType = [MatchReason]

    static func write(_ value: [MatchReason], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeMatchReason.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [MatchReason] {
        let len: Int32 = try buf.readInt()
        var seq = [MatchReason]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMatchReason.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeGuid: FfiConverterRustBuffer {
    typealias SwiftType = [Guid]

    static func write(_ value: [Guid], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeGuid.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [Guid] {
        let len: Int32 = try buf.readInt()
        var seq = [Guid]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGuid.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeUrl: FfiConverterRustBuffer {
    typealias SwiftType = [Url]

    static func write(_ value: [Url], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeUrl.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [Url] {
        let len: Int32 = try buf.readInt()
        var seq = [Url]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUrl.read(from: buf))
        }
        return seq
    }
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Guid = String
private typealias FfiConverterTypeGuid = FfiConverterString

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PlacesTimestamp = Int64
private typealias FfiConverterTypePlacesTimestamp = FfiConverterInt64

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Url = String
private typealias FfiConverterTypeUrl = FfiConverterString

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias VisitTransitionSet = Int32
private typealias FfiConverterTypeVisitTransitionSet = FfiConverterInt32

public func placesApiNew(dbPath: String) throws -> PlacesApi {
    return try FfiConverterTypePlacesApi.lift(
        try

            rustCallWithError(FfiConverterTypePlacesError.self) {
                places_3413_places_api_new(
                    FfiConverterString.lower(dbPath), $0
                )
            }
    )
}

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum PlacesLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {}
}
