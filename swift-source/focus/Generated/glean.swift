// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(MozillaRustComponents)
    import MozillaRustComponents
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_glean_b8a5_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_glean_b8a5_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// A helper class to read values out of a byte buffer.
private class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset ..< offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        _ = withUnsafeMutableBytes(of: &value) { data.copyBytes(to: $0, from: range) }
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads an arbitrary number of bytes, to be used to read
    // raw bytes, this is useful when lifting strings
    func readBytes(count: Int) throws -> [UInt8] {
        let range = offset ..< (offset + count)
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        var value = [UInt8](repeating: 0, count: count)
        value.withUnsafeMutableBufferPointer { buffer in
            data.copyBytes(to: buffer, from: range)
        }
        offset = range.upperBound
        return value
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
private class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        bytes = []
        offset = 0
    }

    func writeBytes<S>(_ byteArr: S) where S: Sequence, S.Element == UInt8 {
        bytes.append(contentsOf: byteArr)
    }

    // Writes an integer in big-endian order.
    //
    // Warning: make sure what you are trying to write
    // is in the correct type!
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        withUnsafeBytes(of: &value) { bytes.append(contentsOf: $0) }
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: Reader) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: Writer)
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    static func lift(_ buf: RustBuffer) throws -> SwiftType {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    static func lower(_ value: SwiftType) -> RustBuffer {
        let writer = Writer()
        write(value, into: writer)
        return RustBuffer(bytes: writer.bytes)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
(_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
{
    try makeRustCall(callback, errorHandler: { try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    static func read(from buf: Reader) throws -> UInt8 {
        return try lift(buf.readInt())
    }

    static func write(_ value: UInt8, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    static func read(from buf: Reader) throws -> Int8 {
        return try lift(buf.readInt())
    }

    static func write(_ value: Int8, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    static func read(from buf: Reader) throws -> UInt32 {
        return try lift(buf.readInt())
    }

    static func write(_ value: SwiftType, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    static func read(from buf: Reader) throws -> Int32 {
        return try lift(buf.readInt())
    }

    static func write(_ value: Int32, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    static func read(from buf: Reader) throws -> UInt64 {
        return try lift(buf.readInt())
    }

    static func write(_ value: SwiftType, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    static func read(from buf: Reader) throws -> Int64 {
        return try lift(buf.readInt())
    }

    static func write(_ value: Int64, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    static func read(from buf: Reader) throws -> Bool {
        return try lift(buf.readInt())
    }

    static func write(_ value: Bool, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    static func read(from buf: Reader) throws -> String {
        let len: Int32 = try buf.readInt()
        return String(bytes: try buf.readBytes(count: Int(len)), encoding: String.Encoding.utf8)!
    }

    static func write(_ value: String, into buf: Writer) {
        let len = Int32(value.utf8.count)
        buf.writeInt(len)
        buf.writeBytes(value.utf8)
    }
}

public protocol BooleanMetricProtocol {
    func set(_ value: Bool)
    func testGetValue(_ pingName: String?) -> Bool?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class BooleanMetric: BooleanMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_BooleanMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_BooleanMetric_object_free(pointer, $0) }
    }

    public func set(_ value: Bool) {
        try!
            rustCall {
                glean_b8a5_BooleanMetric_set(self.pointer,
                                             FfiConverterBool.lower(value), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> Bool? {
        return try! FfiConverterOptionBool.lift(
            try!
                rustCall {
                    glean_b8a5_BooleanMetric_test_get_value(self.pointer,
                                                            FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_BooleanMetric_test_get_num_recorded_errors(self.pointer,
                                                                          FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeBooleanMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BooleanMetric

    static func read(from buf: Reader) throws -> BooleanMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: BooleanMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BooleanMetric {
        return BooleanMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: BooleanMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol CounterMetricProtocol {
    func add(_ amount: Int32)
    func testGetValue(_ pingName: String?) -> Int32?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class CounterMetric: CounterMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_CounterMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_CounterMetric_object_free(pointer, $0) }
    }

    public func add(_ amount: Int32 = 1) {
        try!
            rustCall {
                glean_b8a5_CounterMetric_add(self.pointer,
                                             FfiConverterInt32.lower(amount), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> Int32? {
        return try! FfiConverterOptionInt32.lift(
            try!
                rustCall {
                    glean_b8a5_CounterMetric_test_get_value(self.pointer,
                                                            FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_CounterMetric_test_get_num_recorded_errors(self.pointer,
                                                                          FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeCounterMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CounterMetric

    static func read(from buf: Reader) throws -> CounterMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: CounterMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CounterMetric {
        return CounterMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: CounterMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol CustomDistributionMetricProtocol {
    func accumulateSamples(_ samples: [Int64])
    func testGetValue(_ pingName: String?) -> DistributionData?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class CustomDistributionMetric: CustomDistributionMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData, _ rangeMin: Int64, _ rangeMax: Int64, _ bucketCount: Int64, _ histogramType: HistogramType) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_CustomDistributionMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta),
                    FfiConverterInt64.lower(rangeMin),
                    FfiConverterInt64.lower(rangeMax),
                    FfiConverterInt64.lower(bucketCount),
                    FfiConverterTypeHistogramType.lower(histogramType), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_CustomDistributionMetric_object_free(pointer, $0) }
    }

    public func accumulateSamples(_ samples: [Int64]) {
        try!
            rustCall {
                glean_b8a5_CustomDistributionMetric_accumulate_samples(self.pointer,
                                                                       FfiConverterSequenceInt64.lower(samples), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> DistributionData? {
        return try! FfiConverterOptionTypeDistributionData.lift(
            try!
                rustCall {
                    glean_b8a5_CustomDistributionMetric_test_get_value(self.pointer,
                                                                       FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_CustomDistributionMetric_test_get_num_recorded_errors(self.pointer,
                                                                                     FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeCustomDistributionMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CustomDistributionMetric

    static func read(from buf: Reader) throws -> CustomDistributionMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: CustomDistributionMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomDistributionMetric {
        return CustomDistributionMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: CustomDistributionMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol DatetimeMetricProtocol {
    func set(_ value: Datetime?)
    func testGetValue(_ pingName: String?) -> Datetime?
    func testGetValueAsString(_ pingName: String?) -> String?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class DatetimeMetric: DatetimeMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData, _ timeUnit: TimeUnit) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_DatetimeMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta),
                    FfiConverterTypeTimeUnit.lower(timeUnit), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_DatetimeMetric_object_free(pointer, $0) }
    }

    public func set(_ value: Datetime? = nil) {
        try!
            rustCall {
                glean_b8a5_DatetimeMetric_set(self.pointer,
                                              FfiConverterOptionTypeDatetime.lower(value), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> Datetime? {
        return try! FfiConverterOptionTypeDatetime.lift(
            try!
                rustCall {
                    glean_b8a5_DatetimeMetric_test_get_value(self.pointer,
                                                             FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetValueAsString(_ pingName: String? = nil) -> String? {
        return try! FfiConverterOptionString.lift(
            try!
                rustCall {
                    glean_b8a5_DatetimeMetric_test_get_value_as_string(self.pointer,
                                                                       FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_DatetimeMetric_test_get_num_recorded_errors(self.pointer,
                                                                           FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeDatetimeMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DatetimeMetric

    static func read(from buf: Reader) throws -> DatetimeMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: DatetimeMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DatetimeMetric {
        return DatetimeMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: DatetimeMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol DenominatorMetricProtocol {
    func add(_ amount: Int32)
    func testGetValue(_ pingName: String?) -> Int32?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class DenominatorMetric: DenominatorMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData, _ numerators: [CommonMetricData]) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_DenominatorMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta),
                    FfiConverterSequenceTypeCommonMetricData.lower(numerators), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_DenominatorMetric_object_free(pointer, $0) }
    }

    public func add(_ amount: Int32) {
        try!
            rustCall {
                glean_b8a5_DenominatorMetric_add(self.pointer,
                                                 FfiConverterInt32.lower(amount), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> Int32? {
        return try! FfiConverterOptionInt32.lift(
            try!
                rustCall {
                    glean_b8a5_DenominatorMetric_test_get_value(self.pointer,
                                                                FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_DenominatorMetric_test_get_num_recorded_errors(self.pointer,
                                                                              FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeDenominatorMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DenominatorMetric

    static func read(from buf: Reader) throws -> DenominatorMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: DenominatorMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DenominatorMetric {
        return DenominatorMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: DenominatorMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol EventMetricProtocol {
    func record(_ extra: [String: String])
    func testGetValue(_ pingName: String?) -> [RecordedEvent]?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class EventMetric: EventMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData, _ allowedExtraKeys: [String]) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_EventMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta),
                    FfiConverterSequenceString.lower(allowedExtraKeys), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_EventMetric_object_free(pointer, $0) }
    }

    public func record(_ extra: [String: String]) {
        try!
            rustCall {
                glean_b8a5_EventMetric_record(self.pointer,
                                              FfiConverterDictionaryStringString.lower(extra), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> [RecordedEvent]? {
        return try! FfiConverterOptionSequenceTypeRecordedEvent.lift(
            try!
                rustCall {
                    glean_b8a5_EventMetric_test_get_value(self.pointer,
                                                          FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_EventMetric_test_get_num_recorded_errors(self.pointer,
                                                                        FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeEventMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventMetric

    static func read(from buf: Reader) throws -> EventMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: EventMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventMetric {
        return EventMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: EventMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol LabeledBooleanProtocol {
    func get(_ label: String) -> BooleanMetric
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class LabeledBoolean: LabeledBooleanProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData, _ labels: [String]?) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_LabeledBoolean_new(
                    FfiConverterTypeCommonMetricData.lower(meta),
                    FfiConverterOptionSequenceString.lower(labels), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_LabeledBoolean_object_free(pointer, $0) }
    }

    public func get(_ label: String) -> BooleanMetric {
        return try! FfiConverterTypeBooleanMetric.lift(
            try!
                rustCall {
                    glean_b8a5_LabeledBoolean_get(self.pointer,
                                                  FfiConverterString.lower(label), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_LabeledBoolean_test_get_num_recorded_errors(self.pointer,
                                                                           FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeLabeledBoolean: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LabeledBoolean

    static func read(from buf: Reader) throws -> LabeledBoolean {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: LabeledBoolean, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LabeledBoolean {
        return LabeledBoolean(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: LabeledBoolean) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol LabeledCounterProtocol {
    func get(_ label: String) -> CounterMetric
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class LabeledCounter: LabeledCounterProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData, _ labels: [String]?) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_LabeledCounter_new(
                    FfiConverterTypeCommonMetricData.lower(meta),
                    FfiConverterOptionSequenceString.lower(labels), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_LabeledCounter_object_free(pointer, $0) }
    }

    public func get(_ label: String) -> CounterMetric {
        return try! FfiConverterTypeCounterMetric.lift(
            try!
                rustCall {
                    glean_b8a5_LabeledCounter_get(self.pointer,
                                                  FfiConverterString.lower(label), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_LabeledCounter_test_get_num_recorded_errors(self.pointer,
                                                                           FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeLabeledCounter: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LabeledCounter

    static func read(from buf: Reader) throws -> LabeledCounter {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: LabeledCounter, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LabeledCounter {
        return LabeledCounter(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: LabeledCounter) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol LabeledStringProtocol {
    func get(_ label: String) -> StringMetric
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class LabeledString: LabeledStringProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData, _ labels: [String]?) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_LabeledString_new(
                    FfiConverterTypeCommonMetricData.lower(meta),
                    FfiConverterOptionSequenceString.lower(labels), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_LabeledString_object_free(pointer, $0) }
    }

    public func get(_ label: String) -> StringMetric {
        return try! FfiConverterTypeStringMetric.lift(
            try!
                rustCall {
                    glean_b8a5_LabeledString_get(self.pointer,
                                                 FfiConverterString.lower(label), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_LabeledString_test_get_num_recorded_errors(self.pointer,
                                                                          FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeLabeledString: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LabeledString

    static func read(from buf: Reader) throws -> LabeledString {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: LabeledString, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LabeledString {
        return LabeledString(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: LabeledString) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol MemoryDistributionMetricProtocol {
    func accumulate(_ sample: Int64)
    func accumulateSamples(_ samples: [Int64])
    func testGetValue(_ pingName: String?) -> DistributionData?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class MemoryDistributionMetric: MemoryDistributionMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData, _ memoryUnit: MemoryUnit) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_MemoryDistributionMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta),
                    FfiConverterTypeMemoryUnit.lower(memoryUnit), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_MemoryDistributionMetric_object_free(pointer, $0) }
    }

    public func accumulate(_ sample: Int64) {
        try!
            rustCall {
                glean_b8a5_MemoryDistributionMetric_accumulate(self.pointer,
                                                               FfiConverterInt64.lower(sample), $0)
            }
    }

    public func accumulateSamples(_ samples: [Int64]) {
        try!
            rustCall {
                glean_b8a5_MemoryDistributionMetric_accumulate_samples(self.pointer,
                                                                       FfiConverterSequenceInt64.lower(samples), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> DistributionData? {
        return try! FfiConverterOptionTypeDistributionData.lift(
            try!
                rustCall {
                    glean_b8a5_MemoryDistributionMetric_test_get_value(self.pointer,
                                                                       FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_MemoryDistributionMetric_test_get_num_recorded_errors(self.pointer,
                                                                                     FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeMemoryDistributionMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MemoryDistributionMetric

    static func read(from buf: Reader) throws -> MemoryDistributionMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: MemoryDistributionMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MemoryDistributionMetric {
        return MemoryDistributionMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: MemoryDistributionMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol NumeratorMetricProtocol {
    func addToNumerator(_ amount: Int32)
    func testGetValue(_ pingName: String?) -> Rate?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class NumeratorMetric: NumeratorMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_NumeratorMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_NumeratorMetric_object_free(pointer, $0) }
    }

    public func addToNumerator(_ amount: Int32) {
        try!
            rustCall {
                glean_b8a5_NumeratorMetric_add_to_numerator(self.pointer,
                                                            FfiConverterInt32.lower(amount), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> Rate? {
        return try! FfiConverterOptionTypeRate.lift(
            try!
                rustCall {
                    glean_b8a5_NumeratorMetric_test_get_value(self.pointer,
                                                              FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_NumeratorMetric_test_get_num_recorded_errors(self.pointer,
                                                                            FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeNumeratorMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NumeratorMetric

    static func read(from buf: Reader) throws -> NumeratorMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: NumeratorMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NumeratorMetric {
        return NumeratorMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: NumeratorMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol PingTypeProtocol {
    func submit(_ reason: String?)
}

public class PingType: PingTypeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ name: String, _ includeClientId: Bool, _ sendIfEmpty: Bool, _ reasonCodes: [String]) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_PingType_new(
                    FfiConverterString.lower(name),
                    FfiConverterBool.lower(includeClientId),
                    FfiConverterBool.lower(sendIfEmpty),
                    FfiConverterSequenceString.lower(reasonCodes), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_PingType_object_free(pointer, $0) }
    }

    public func submit(_ reason: String? = nil) {
        try!
            rustCall {
                glean_b8a5_PingType_submit(self.pointer,
                                           FfiConverterOptionString.lower(reason), $0)
            }
    }
}

private struct FfiConverterTypePingType: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PingType

    static func read(from buf: Reader) throws -> PingType {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: PingType, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PingType {
        return PingType(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: PingType) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol QuantityMetricProtocol {
    func set(_ value: Int64)
    func testGetValue(_ pingName: String?) -> Int64?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class QuantityMetric: QuantityMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_QuantityMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_QuantityMetric_object_free(pointer, $0) }
    }

    public func set(_ value: Int64) {
        try!
            rustCall {
                glean_b8a5_QuantityMetric_set(self.pointer,
                                              FfiConverterInt64.lower(value), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> Int64? {
        return try! FfiConverterOptionInt64.lift(
            try!
                rustCall {
                    glean_b8a5_QuantityMetric_test_get_value(self.pointer,
                                                             FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_QuantityMetric_test_get_num_recorded_errors(self.pointer,
                                                                           FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeQuantityMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = QuantityMetric

    static func read(from buf: Reader) throws -> QuantityMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: QuantityMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> QuantityMetric {
        return QuantityMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: QuantityMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol RateMetricProtocol {
    func addToNumerator(_ amount: Int32)
    func addToDenominator(_ amount: Int32)
    func testGetValue(_ pingName: String?) -> Rate?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class RateMetric: RateMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_RateMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_RateMetric_object_free(pointer, $0) }
    }

    public func addToNumerator(_ amount: Int32) {
        try!
            rustCall {
                glean_b8a5_RateMetric_add_to_numerator(self.pointer,
                                                       FfiConverterInt32.lower(amount), $0)
            }
    }

    public func addToDenominator(_ amount: Int32) {
        try!
            rustCall {
                glean_b8a5_RateMetric_add_to_denominator(self.pointer,
                                                         FfiConverterInt32.lower(amount), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> Rate? {
        return try! FfiConverterOptionTypeRate.lift(
            try!
                rustCall {
                    glean_b8a5_RateMetric_test_get_value(self.pointer,
                                                         FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_RateMetric_test_get_num_recorded_errors(self.pointer,
                                                                       FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeRateMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RateMetric

    static func read(from buf: Reader) throws -> RateMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: RateMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RateMetric {
        return RateMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: RateMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol StringListMetricProtocol {
    func add(_ value: String)
    func set(_ value: [String])
    func testGetValue(_ pingName: String?) -> [String]?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class StringListMetric: StringListMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_StringListMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_StringListMetric_object_free(pointer, $0) }
    }

    public func add(_ value: String) {
        try!
            rustCall {
                glean_b8a5_StringListMetric_add(self.pointer,
                                                FfiConverterString.lower(value), $0)
            }
    }

    public func set(_ value: [String]) {
        try!
            rustCall {
                glean_b8a5_StringListMetric_set(self.pointer,
                                                FfiConverterSequenceString.lower(value), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> [String]? {
        return try! FfiConverterOptionSequenceString.lift(
            try!
                rustCall {
                    glean_b8a5_StringListMetric_test_get_value(self.pointer,
                                                               FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_StringListMetric_test_get_num_recorded_errors(self.pointer,
                                                                             FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeStringListMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = StringListMetric

    static func read(from buf: Reader) throws -> StringListMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: StringListMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> StringListMetric {
        return StringListMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: StringListMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol StringMetricProtocol {
    func set(_ value: String)
    func testGetValue(_ pingName: String?) -> String?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class StringMetric: StringMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_StringMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_StringMetric_object_free(pointer, $0) }
    }

    public func set(_ value: String) {
        try!
            rustCall {
                glean_b8a5_StringMetric_set(self.pointer,
                                            FfiConverterString.lower(value), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> String? {
        return try! FfiConverterOptionString.lift(
            try!
                rustCall {
                    glean_b8a5_StringMetric_test_get_value(self.pointer,
                                                           FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_StringMetric_test_get_num_recorded_errors(self.pointer,
                                                                         FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeStringMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = StringMetric

    static func read(from buf: Reader) throws -> StringMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: StringMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> StringMetric {
        return StringMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: StringMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol TextMetricProtocol {
    func set(_ value: String)
    func testGetValue(_ pingName: String?) -> String?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class TextMetric: TextMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_TextMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_TextMetric_object_free(pointer, $0) }
    }

    public func set(_ value: String) {
        try!
            rustCall {
                glean_b8a5_TextMetric_set(self.pointer,
                                          FfiConverterString.lower(value), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> String? {
        return try! FfiConverterOptionString.lift(
            try!
                rustCall {
                    glean_b8a5_TextMetric_test_get_value(self.pointer,
                                                         FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_TextMetric_test_get_num_recorded_errors(self.pointer,
                                                                       FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeTextMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TextMetric

    static func read(from buf: Reader) throws -> TextMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: TextMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TextMetric {
        return TextMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: TextMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol TimespanMetricProtocol {
    func start()
    func stop()
    func cancel()
    func setRawNanos(_ elapsed: Int64)
    func testGetValue(_ pingName: String?) -> Int64?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class TimespanMetric: TimespanMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData, _ timeUnit: TimeUnit) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_TimespanMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta),
                    FfiConverterTypeTimeUnit.lower(timeUnit), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_TimespanMetric_object_free(pointer, $0) }
    }

    public func start() {
        try!
            rustCall {
                glean_b8a5_TimespanMetric_start(self.pointer, $0)
            }
    }

    public func stop() {
        try!
            rustCall {
                glean_b8a5_TimespanMetric_stop(self.pointer, $0)
            }
    }

    public func cancel() {
        try!
            rustCall {
                glean_b8a5_TimespanMetric_cancel(self.pointer, $0)
            }
    }

    public func setRawNanos(_ elapsed: Int64) {
        try!
            rustCall {
                glean_b8a5_TimespanMetric_set_raw_nanos(self.pointer,
                                                        FfiConverterInt64.lower(elapsed), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> Int64? {
        return try! FfiConverterOptionInt64.lift(
            try!
                rustCall {
                    glean_b8a5_TimespanMetric_test_get_value(self.pointer,
                                                             FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_TimespanMetric_test_get_num_recorded_errors(self.pointer,
                                                                           FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeTimespanMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimespanMetric

    static func read(from buf: Reader) throws -> TimespanMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: TimespanMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimespanMetric {
        return TimespanMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: TimespanMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol TimingDistributionMetricProtocol {
    func start() -> TimerId
    func stopAndAccumulate(_ timerId: TimerId)
    func cancel(_ timerId: TimerId)
    func accumulateSamples(_ samples: [Int64])
    func testGetValue(_ pingName: String?) -> DistributionData?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class TimingDistributionMetric: TimingDistributionMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData, _ timeUnit: TimeUnit) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_TimingDistributionMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta),
                    FfiConverterTypeTimeUnit.lower(timeUnit), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_TimingDistributionMetric_object_free(pointer, $0) }
    }

    public func start() -> TimerId {
        return try! FfiConverterTypeTimerId.lift(
            try!
                rustCall {
                    glean_b8a5_TimingDistributionMetric_start(self.pointer, $0)
                }
        )
    }

    public func stopAndAccumulate(_ timerId: TimerId) {
        try!
            rustCall {
                glean_b8a5_TimingDistributionMetric_stop_and_accumulate(self.pointer,
                                                                        FfiConverterTypeTimerId.lower(timerId), $0)
            }
    }

    public func cancel(_ timerId: TimerId) {
        try!
            rustCall {
                glean_b8a5_TimingDistributionMetric_cancel(self.pointer,
                                                           FfiConverterTypeTimerId.lower(timerId), $0)
            }
    }

    public func accumulateSamples(_ samples: [Int64]) {
        try!
            rustCall {
                glean_b8a5_TimingDistributionMetric_accumulate_samples(self.pointer,
                                                                       FfiConverterSequenceInt64.lower(samples), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> DistributionData? {
        return try! FfiConverterOptionTypeDistributionData.lift(
            try!
                rustCall {
                    glean_b8a5_TimingDistributionMetric_test_get_value(self.pointer,
                                                                       FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_TimingDistributionMetric_test_get_num_recorded_errors(self.pointer,
                                                                                     FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeTimingDistributionMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimingDistributionMetric

    static func read(from buf: Reader) throws -> TimingDistributionMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: TimingDistributionMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimingDistributionMetric {
        return TimingDistributionMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: TimingDistributionMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol UrlMetricProtocol {
    func set(_ value: String)
    func testGetValue(_ pingName: String?) -> String?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class UrlMetric: UrlMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_UrlMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_UrlMetric_object_free(pointer, $0) }
    }

    public func set(_ value: String) {
        try!
            rustCall {
                glean_b8a5_UrlMetric_set(self.pointer,
                                         FfiConverterString.lower(value), $0)
            }
    }

    public func testGetValue(_ pingName: String? = nil) -> String? {
        return try! FfiConverterOptionString.lift(
            try!
                rustCall {
                    glean_b8a5_UrlMetric_test_get_value(self.pointer,
                                                        FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_UrlMetric_test_get_num_recorded_errors(self.pointer,
                                                                      FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeUrlMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UrlMetric

    static func read(from buf: Reader) throws -> UrlMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: UrlMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UrlMetric {
        return UrlMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: UrlMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol UuidMetricProtocol {
    func set(_ value: String)
    func generateAndSet() -> String
    func testGetValue(_ pingName: String?) -> String?
    func testGetNumRecordedErrors(_ error: ErrorType) -> Int32
}

public class UuidMetric: UuidMetricProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(_ meta: CommonMetricData) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                glean_b8a5_UuidMetric_new(
                    FfiConverterTypeCommonMetricData.lower(meta), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_glean_b8a5_UuidMetric_object_free(pointer, $0) }
    }

    public func set(_ value: String) {
        try!
            rustCall {
                glean_b8a5_UuidMetric_set(self.pointer,
                                          FfiConverterString.lower(value), $0)
            }
    }

    public func generateAndSet() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    glean_b8a5_UuidMetric_generate_and_set(self.pointer, $0)
                }
        )
    }

    public func testGetValue(_ pingName: String? = nil) -> String? {
        return try! FfiConverterOptionString.lift(
            try!
                rustCall {
                    glean_b8a5_UuidMetric_test_get_value(self.pointer,
                                                         FfiConverterOptionString.lower(pingName), $0)
                }
        )
    }

    public func testGetNumRecordedErrors(_ error: ErrorType) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    glean_b8a5_UuidMetric_test_get_num_recorded_errors(self.pointer,
                                                                       FfiConverterTypeErrorType.lower(error), $0)
                }
        )
    }
}

private struct FfiConverterTypeUuidMetric: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UuidMetric

    static func read(from buf: Reader) throws -> UuidMetric {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: UuidMetric, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UuidMetric {
        return UuidMetric(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: UuidMetric) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public struct ClientInfoMetrics {
    public var appBuild: String
    public var appDisplayVersion: String
    public var appBuildDate: Datetime
    public var architecture: String
    public var osVersion: String
    public var channel: String?
    public var locale: String?
    public var deviceManufacturer: String?
    public var deviceModel: String?
    public var androidSdkVersion: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(appBuild: String, appDisplayVersion: String, appBuildDate: Datetime, architecture: String, osVersion: String, channel: String? = nil, locale: String? = nil, deviceManufacturer: String? = nil, deviceModel: String? = nil, androidSdkVersion: String? = nil) {
        self.appBuild = appBuild
        self.appDisplayVersion = appDisplayVersion
        self.appBuildDate = appBuildDate
        self.architecture = architecture
        self.osVersion = osVersion
        self.channel = channel
        self.locale = locale
        self.deviceManufacturer = deviceManufacturer
        self.deviceModel = deviceModel
        self.androidSdkVersion = androidSdkVersion
    }
}

extension ClientInfoMetrics: Equatable, Hashable {
    public static func == (lhs: ClientInfoMetrics, rhs: ClientInfoMetrics) -> Bool {
        if lhs.appBuild != rhs.appBuild {
            return false
        }
        if lhs.appDisplayVersion != rhs.appDisplayVersion {
            return false
        }
        if lhs.appBuildDate != rhs.appBuildDate {
            return false
        }
        if lhs.architecture != rhs.architecture {
            return false
        }
        if lhs.osVersion != rhs.osVersion {
            return false
        }
        if lhs.channel != rhs.channel {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.deviceManufacturer != rhs.deviceManufacturer {
            return false
        }
        if lhs.deviceModel != rhs.deviceModel {
            return false
        }
        if lhs.androidSdkVersion != rhs.androidSdkVersion {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(appBuild)
        hasher.combine(appDisplayVersion)
        hasher.combine(appBuildDate)
        hasher.combine(architecture)
        hasher.combine(osVersion)
        hasher.combine(channel)
        hasher.combine(locale)
        hasher.combine(deviceManufacturer)
        hasher.combine(deviceModel)
        hasher.combine(androidSdkVersion)
    }
}

private struct FfiConverterTypeClientInfoMetrics: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> ClientInfoMetrics {
        return try ClientInfoMetrics(
            appBuild: FfiConverterString.read(from: buf),
            appDisplayVersion: FfiConverterString.read(from: buf),
            appBuildDate: FfiConverterTypeDatetime.read(from: buf),
            architecture: FfiConverterString.read(from: buf),
            osVersion: FfiConverterString.read(from: buf),
            channel: FfiConverterOptionString.read(from: buf),
            locale: FfiConverterOptionString.read(from: buf),
            deviceManufacturer: FfiConverterOptionString.read(from: buf),
            deviceModel: FfiConverterOptionString.read(from: buf),
            androidSdkVersion: FfiConverterOptionString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: ClientInfoMetrics, into buf: Writer) {
        FfiConverterString.write(value.appBuild, into: buf)
        FfiConverterString.write(value.appDisplayVersion, into: buf)
        FfiConverterTypeDatetime.write(value.appBuildDate, into: buf)
        FfiConverterString.write(value.architecture, into: buf)
        FfiConverterString.write(value.osVersion, into: buf)
        FfiConverterOptionString.write(value.channel, into: buf)
        FfiConverterOptionString.write(value.locale, into: buf)
        FfiConverterOptionString.write(value.deviceManufacturer, into: buf)
        FfiConverterOptionString.write(value.deviceModel, into: buf)
        FfiConverterOptionString.write(value.androidSdkVersion, into: buf)
    }
}

public struct CommonMetricData {
    public var category: String
    public var name: String
    public var sendInPings: [String]
    public var lifetime: Lifetime
    public var disabled: Bool
    public var dynamicLabel: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(category: String, name: String, sendInPings: [String], lifetime: Lifetime, disabled: Bool, dynamicLabel: String? = nil) {
        self.category = category
        self.name = name
        self.sendInPings = sendInPings
        self.lifetime = lifetime
        self.disabled = disabled
        self.dynamicLabel = dynamicLabel
    }
}

extension CommonMetricData: Equatable, Hashable {
    public static func == (lhs: CommonMetricData, rhs: CommonMetricData) -> Bool {
        if lhs.category != rhs.category {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.sendInPings != rhs.sendInPings {
            return false
        }
        if lhs.lifetime != rhs.lifetime {
            return false
        }
        if lhs.disabled != rhs.disabled {
            return false
        }
        if lhs.dynamicLabel != rhs.dynamicLabel {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(category)
        hasher.combine(name)
        hasher.combine(sendInPings)
        hasher.combine(lifetime)
        hasher.combine(disabled)
        hasher.combine(dynamicLabel)
    }
}

private struct FfiConverterTypeCommonMetricData: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> CommonMetricData {
        return try CommonMetricData(
            category: FfiConverterString.read(from: buf),
            name: FfiConverterString.read(from: buf),
            sendInPings: FfiConverterSequenceString.read(from: buf),
            lifetime: FfiConverterTypeLifetime.read(from: buf),
            disabled: FfiConverterBool.read(from: buf),
            dynamicLabel: FfiConverterOptionString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: CommonMetricData, into buf: Writer) {
        FfiConverterString.write(value.category, into: buf)
        FfiConverterString.write(value.name, into: buf)
        FfiConverterSequenceString.write(value.sendInPings, into: buf)
        FfiConverterTypeLifetime.write(value.lifetime, into: buf)
        FfiConverterBool.write(value.disabled, into: buf)
        FfiConverterOptionString.write(value.dynamicLabel, into: buf)
    }
}

public struct Datetime {
    public var year: Int32
    public var month: UInt32
    public var day: UInt32
    public var hour: UInt32
    public var minute: UInt32
    public var second: UInt32
    public var nanosecond: UInt32
    public var offsetSeconds: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(year: Int32, month: UInt32, day: UInt32, hour: UInt32, minute: UInt32, second: UInt32, nanosecond: UInt32, offsetSeconds: Int32) {
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second
        self.nanosecond = nanosecond
        self.offsetSeconds = offsetSeconds
    }
}

extension Datetime: Equatable, Hashable {
    public static func == (lhs: Datetime, rhs: Datetime) -> Bool {
        if lhs.year != rhs.year {
            return false
        }
        if lhs.month != rhs.month {
            return false
        }
        if lhs.day != rhs.day {
            return false
        }
        if lhs.hour != rhs.hour {
            return false
        }
        if lhs.minute != rhs.minute {
            return false
        }
        if lhs.second != rhs.second {
            return false
        }
        if lhs.nanosecond != rhs.nanosecond {
            return false
        }
        if lhs.offsetSeconds != rhs.offsetSeconds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(year)
        hasher.combine(month)
        hasher.combine(day)
        hasher.combine(hour)
        hasher.combine(minute)
        hasher.combine(second)
        hasher.combine(nanosecond)
        hasher.combine(offsetSeconds)
    }
}

private struct FfiConverterTypeDatetime: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Datetime {
        return try Datetime(
            year: FfiConverterInt32.read(from: buf),
            month: FfiConverterUInt32.read(from: buf),
            day: FfiConverterUInt32.read(from: buf),
            hour: FfiConverterUInt32.read(from: buf),
            minute: FfiConverterUInt32.read(from: buf),
            second: FfiConverterUInt32.read(from: buf),
            nanosecond: FfiConverterUInt32.read(from: buf),
            offsetSeconds: FfiConverterInt32.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Datetime, into buf: Writer) {
        FfiConverterInt32.write(value.year, into: buf)
        FfiConverterUInt32.write(value.month, into: buf)
        FfiConverterUInt32.write(value.day, into: buf)
        FfiConverterUInt32.write(value.hour, into: buf)
        FfiConverterUInt32.write(value.minute, into: buf)
        FfiConverterUInt32.write(value.second, into: buf)
        FfiConverterUInt32.write(value.nanosecond, into: buf)
        FfiConverterInt32.write(value.offsetSeconds, into: buf)
    }
}

public struct DistributionData {
    public var values: [Int64: Int64]
    public var sum: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(values: [Int64: Int64], sum: Int64) {
        self.values = values
        self.sum = sum
    }
}

extension DistributionData: Equatable, Hashable {
    public static func == (lhs: DistributionData, rhs: DistributionData) -> Bool {
        if lhs.values != rhs.values {
            return false
        }
        if lhs.sum != rhs.sum {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(values)
        hasher.combine(sum)
    }
}

private struct FfiConverterTypeDistributionData: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> DistributionData {
        return try DistributionData(
            values: FfiConverterDictionaryInt64Int64.read(from: buf),
            sum: FfiConverterInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: DistributionData, into buf: Writer) {
        FfiConverterDictionaryInt64Int64.write(value.values, into: buf)
        FfiConverterInt64.write(value.sum, into: buf)
    }
}

public struct InternalConfiguration {
    public var dataPath: String
    public var applicationId: String
    public var languageBindingName: String
    public var uploadEnabled: Bool
    public var maxEvents: UInt32?
    public var delayPingLifetimeIo: Bool
    public var appBuild: String
    public var useCoreMps: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(dataPath: String, applicationId: String, languageBindingName: String, uploadEnabled: Bool, maxEvents: UInt32?, delayPingLifetimeIo: Bool, appBuild: String, useCoreMps: Bool) {
        self.dataPath = dataPath
        self.applicationId = applicationId
        self.languageBindingName = languageBindingName
        self.uploadEnabled = uploadEnabled
        self.maxEvents = maxEvents
        self.delayPingLifetimeIo = delayPingLifetimeIo
        self.appBuild = appBuild
        self.useCoreMps = useCoreMps
    }
}

extension InternalConfiguration: Equatable, Hashable {
    public static func == (lhs: InternalConfiguration, rhs: InternalConfiguration) -> Bool {
        if lhs.dataPath != rhs.dataPath {
            return false
        }
        if lhs.applicationId != rhs.applicationId {
            return false
        }
        if lhs.languageBindingName != rhs.languageBindingName {
            return false
        }
        if lhs.uploadEnabled != rhs.uploadEnabled {
            return false
        }
        if lhs.maxEvents != rhs.maxEvents {
            return false
        }
        if lhs.delayPingLifetimeIo != rhs.delayPingLifetimeIo {
            return false
        }
        if lhs.appBuild != rhs.appBuild {
            return false
        }
        if lhs.useCoreMps != rhs.useCoreMps {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(dataPath)
        hasher.combine(applicationId)
        hasher.combine(languageBindingName)
        hasher.combine(uploadEnabled)
        hasher.combine(maxEvents)
        hasher.combine(delayPingLifetimeIo)
        hasher.combine(appBuild)
        hasher.combine(useCoreMps)
    }
}

private struct FfiConverterTypeInternalConfiguration: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> InternalConfiguration {
        return try InternalConfiguration(
            dataPath: FfiConverterString.read(from: buf),
            applicationId: FfiConverterString.read(from: buf),
            languageBindingName: FfiConverterString.read(from: buf),
            uploadEnabled: FfiConverterBool.read(from: buf),
            maxEvents: FfiConverterOptionUInt32.read(from: buf),
            delayPingLifetimeIo: FfiConverterBool.read(from: buf),
            appBuild: FfiConverterString.read(from: buf),
            useCoreMps: FfiConverterBool.read(from: buf)
        )
    }

    fileprivate static func write(_ value: InternalConfiguration, into buf: Writer) {
        FfiConverterString.write(value.dataPath, into: buf)
        FfiConverterString.write(value.applicationId, into: buf)
        FfiConverterString.write(value.languageBindingName, into: buf)
        FfiConverterBool.write(value.uploadEnabled, into: buf)
        FfiConverterOptionUInt32.write(value.maxEvents, into: buf)
        FfiConverterBool.write(value.delayPingLifetimeIo, into: buf)
        FfiConverterString.write(value.appBuild, into: buf)
        FfiConverterBool.write(value.useCoreMps, into: buf)
    }
}

public struct PingRequest {
    public var documentId: String
    public var path: String
    public var body: [UInt8]
    public var headers: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(documentId: String, path: String, body: [UInt8], headers: [String: String]) {
        self.documentId = documentId
        self.path = path
        self.body = body
        self.headers = headers
    }
}

extension PingRequest: Equatable, Hashable {
    public static func == (lhs: PingRequest, rhs: PingRequest) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(path)
        hasher.combine(body)
        hasher.combine(headers)
    }
}

private struct FfiConverterTypePingRequest: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> PingRequest {
        return try PingRequest(
            documentId: FfiConverterString.read(from: buf),
            path: FfiConverterString.read(from: buf),
            body: FfiConverterSequenceUInt8.read(from: buf),
            headers: FfiConverterDictionaryStringString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: PingRequest, into buf: Writer) {
        FfiConverterString.write(value.documentId, into: buf)
        FfiConverterString.write(value.path, into: buf)
        FfiConverterSequenceUInt8.write(value.body, into: buf)
        FfiConverterDictionaryStringString.write(value.headers, into: buf)
    }
}

public struct Rate {
    public var numerator: Int32
    public var denominator: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numerator: Int32, denominator: Int32) {
        self.numerator = numerator
        self.denominator = denominator
    }
}

extension Rate: Equatable, Hashable {
    public static func == (lhs: Rate, rhs: Rate) -> Bool {
        if lhs.numerator != rhs.numerator {
            return false
        }
        if lhs.denominator != rhs.denominator {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numerator)
        hasher.combine(denominator)
    }
}

private struct FfiConverterTypeRate: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Rate {
        return try Rate(
            numerator: FfiConverterInt32.read(from: buf),
            denominator: FfiConverterInt32.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Rate, into buf: Writer) {
        FfiConverterInt32.write(value.numerator, into: buf)
        FfiConverterInt32.write(value.denominator, into: buf)
    }
}

public struct RecordedEvent {
    public var timestamp: UInt64
    public var category: String
    public var name: String
    public var extra: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(timestamp: UInt64, category: String, name: String, extra: [String: String]?) {
        self.timestamp = timestamp
        self.category = category
        self.name = name
        self.extra = extra
    }
}

extension RecordedEvent: Equatable, Hashable {
    public static func == (lhs: RecordedEvent, rhs: RecordedEvent) -> Bool {
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.category != rhs.category {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.extra != rhs.extra {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(timestamp)
        hasher.combine(category)
        hasher.combine(name)
        hasher.combine(extra)
    }
}

private struct FfiConverterTypeRecordedEvent: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> RecordedEvent {
        return try RecordedEvent(
            timestamp: FfiConverterUInt64.read(from: buf),
            category: FfiConverterString.read(from: buf),
            name: FfiConverterString.read(from: buf),
            extra: FfiConverterOptionDictionaryStringString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: RecordedEvent, into buf: Writer) {
        FfiConverterUInt64.write(value.timestamp, into: buf)
        FfiConverterString.write(value.category, into: buf)
        FfiConverterString.write(value.name, into: buf)
        FfiConverterOptionDictionaryStringString.write(value.extra, into: buf)
    }
}

public struct RecordedExperiment {
    public var branch: String
    public var extra: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(branch: String, extra: [String: String]?) {
        self.branch = branch
        self.extra = extra
    }
}

extension RecordedExperiment: Equatable, Hashable {
    public static func == (lhs: RecordedExperiment, rhs: RecordedExperiment) -> Bool {
        if lhs.branch != rhs.branch {
            return false
        }
        if lhs.extra != rhs.extra {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(branch)
        hasher.combine(extra)
    }
}

private struct FfiConverterTypeRecordedExperiment: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> RecordedExperiment {
        return try RecordedExperiment(
            branch: FfiConverterString.read(from: buf),
            extra: FfiConverterOptionDictionaryStringString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: RecordedExperiment, into buf: Writer) {
        FfiConverterString.write(value.branch, into: buf)
        FfiConverterOptionDictionaryStringString.write(value.extra, into: buf)
    }
}

public struct TimerId {
    public var id: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt64) {
        self.id = id
    }
}

extension TimerId: Equatable, Hashable {
    public static func == (lhs: TimerId, rhs: TimerId) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}

private struct FfiConverterTypeTimerId: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> TimerId {
        return try TimerId(
            id: FfiConverterUInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: TimerId, into buf: Writer) {
        FfiConverterUInt64.write(value.id, into: buf)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ErrorType {
    case invalidValue
    case invalidLabel
    case invalidState
    case invalidOverflow
}

private struct FfiConverterTypeErrorType: FfiConverterRustBuffer {
    typealias SwiftType = ErrorType

    static func read(from buf: Reader) throws -> ErrorType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .invalidValue

        case 2: return .invalidLabel

        case 3: return .invalidState

        case 4: return .invalidOverflow

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: ErrorType, into buf: Writer) {
        switch value {
        case .invalidValue:
            buf.writeInt(Int32(1))

        case .invalidLabel:
            buf.writeInt(Int32(2))

        case .invalidState:
            buf.writeInt(Int32(3))

        case .invalidOverflow:
            buf.writeInt(Int32(4))
        }
    }
}

extension ErrorType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum HistogramType {
    case linear
    case exponential
}

private struct FfiConverterTypeHistogramType: FfiConverterRustBuffer {
    typealias SwiftType = HistogramType

    static func read(from buf: Reader) throws -> HistogramType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .linear

        case 2: return .exponential

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: HistogramType, into buf: Writer) {
        switch value {
        case .linear:
            buf.writeInt(Int32(1))

        case .exponential:
            buf.writeInt(Int32(2))
        }
    }
}

extension HistogramType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Lifetime {
    case ping
    case application
    case user
}

private struct FfiConverterTypeLifetime: FfiConverterRustBuffer {
    typealias SwiftType = Lifetime

    static func read(from buf: Reader) throws -> Lifetime {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .ping

        case 2: return .application

        case 3: return .user

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: Lifetime, into buf: Writer) {
        switch value {
        case .ping:
            buf.writeInt(Int32(1))

        case .application:
            buf.writeInt(Int32(2))

        case .user:
            buf.writeInt(Int32(3))
        }
    }
}

extension Lifetime: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MemoryUnit {
    case byte
    case kilobyte
    case megabyte
    case gigabyte
}

private struct FfiConverterTypeMemoryUnit: FfiConverterRustBuffer {
    typealias SwiftType = MemoryUnit

    static func read(from buf: Reader) throws -> MemoryUnit {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .byte

        case 2: return .kilobyte

        case 3: return .megabyte

        case 4: return .gigabyte

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: MemoryUnit, into buf: Writer) {
        switch value {
        case .byte:
            buf.writeInt(Int32(1))

        case .kilobyte:
            buf.writeInt(Int32(2))

        case .megabyte:
            buf.writeInt(Int32(3))

        case .gigabyte:
            buf.writeInt(Int32(4))
        }
    }
}

extension MemoryUnit: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PingUploadTask {
    case upload(request: PingRequest)
    case wait(time: UInt64)
    case done(unused: Int8)
}

private struct FfiConverterTypePingUploadTask: FfiConverterRustBuffer {
    typealias SwiftType = PingUploadTask

    static func read(from buf: Reader) throws -> PingUploadTask {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .upload(
                request: try FfiConverterTypePingRequest.read(from: buf)
            )

        case 2: return .wait(
                time: try FfiConverterUInt64.read(from: buf)
            )

        case 3: return .done(
                unused: try FfiConverterInt8.read(from: buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: PingUploadTask, into buf: Writer) {
        switch value {
        case let .upload(request):
            buf.writeInt(Int32(1))
            FfiConverterTypePingRequest.write(request, into: buf)

        case let .wait(time):
            buf.writeInt(Int32(2))
            FfiConverterUInt64.write(time, into: buf)

        case let .done(unused):
            buf.writeInt(Int32(3))
            FfiConverterInt8.write(unused, into: buf)
        }
    }
}

extension PingUploadTask: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TimeUnit {
    case nanosecond
    case microsecond
    case millisecond
    case second
    case minute
    case hour
    case day
}

private struct FfiConverterTypeTimeUnit: FfiConverterRustBuffer {
    typealias SwiftType = TimeUnit

    static func read(from buf: Reader) throws -> TimeUnit {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .nanosecond

        case 2: return .microsecond

        case 3: return .millisecond

        case 4: return .second

        case 5: return .minute

        case 6: return .hour

        case 7: return .day

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: TimeUnit, into buf: Writer) {
        switch value {
        case .nanosecond:
            buf.writeInt(Int32(1))

        case .microsecond:
            buf.writeInt(Int32(2))

        case .millisecond:
            buf.writeInt(Int32(3))

        case .second:
            buf.writeInt(Int32(4))

        case .minute:
            buf.writeInt(Int32(5))

        case .hour:
            buf.writeInt(Int32(6))

        case .day:
            buf.writeInt(Int32(7))
        }
    }
}

extension TimeUnit: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum UploadResult {
    case recoverableFailure(unused: Int8)
    case unrecoverableFailure(unused: Int8)
    case httpStatus(code: Int32)
    case done(unused: Int8)
}

private struct FfiConverterTypeUploadResult: FfiConverterRustBuffer {
    typealias SwiftType = UploadResult

    static func read(from buf: Reader) throws -> UploadResult {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .recoverableFailure(
                unused: try FfiConverterInt8.read(from: buf)
            )

        case 2: return .unrecoverableFailure(
                unused: try FfiConverterInt8.read(from: buf)
            )

        case 3: return .httpStatus(
                code: try FfiConverterInt32.read(from: buf)
            )

        case 4: return .done(
                unused: try FfiConverterInt8.read(from: buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: UploadResult, into buf: Writer) {
        switch value {
        case let .recoverableFailure(unused):
            buf.writeInt(Int32(1))
            FfiConverterInt8.write(unused, into: buf)

        case let .unrecoverableFailure(unused):
            buf.writeInt(Int32(2))
            FfiConverterInt8.write(unused, into: buf)

        case let .httpStatus(code):
            buf.writeInt(Int32(3))
            FfiConverterInt32.write(code, into: buf)

        case let .done(unused):
            buf.writeInt(Int32(4))
            FfiConverterInt8.write(unused, into: buf)
        }
    }
}

extension UploadResult: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum UploadTaskAction {
    case next
    case end
}

private struct FfiConverterTypeUploadTaskAction: FfiConverterRustBuffer {
    typealias SwiftType = UploadTaskAction

    static func read(from buf: Reader) throws -> UploadTaskAction {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .next

        case 2: return .end

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: UploadTaskAction, into buf: Writer) {
        switch value {
        case .next:
            buf.writeInt(Int32(1))

        case .end:
            buf.writeInt(Int32(2))
        }
    }
}

extension UploadTaskAction: Equatable, Hashable {}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private typealias Handle = UInt64
private class ConcurrentHandleMap<T> {
    private var leftMap: [Handle: T] = [:]
    private var counter: [Handle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: Handle] = [:]

    private let lock = NSLock()
    private var currentHandle: Handle = 0
    private let stride: Handle = 1

    func insert(obj: T) -> Handle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: Handle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: Handle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: Handle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0

// Declaration and FfiConverters for OnGleanEvents Callback Interface

public protocol OnGleanEvents: AnyObject {
    func onInitializeFinished()
    func triggerUpload()
    func startMetricsPingScheduler() -> Bool
    func cancelUploads()
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceOnGleanEvents: ForeignCallback =
    { (handle: Handle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func invokeOnInitializeFinished(_ swiftCallbackInterface: OnGleanEvents, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            swiftCallbackInterface.onInitializeFinished()
            return RustBuffer()
            // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }
        func invokeTriggerUpload(_ swiftCallbackInterface: OnGleanEvents, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            swiftCallbackInterface.triggerUpload()
            return RustBuffer()
            // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }
        func invokeStartMetricsPingScheduler(_ swiftCallbackInterface: OnGleanEvents, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            let result = swiftCallbackInterface.startMetricsPingScheduler()
            let writer = Writer()
            FfiConverterBool.write(result, into: writer)
            return RustBuffer(bytes: writer.bytes) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }
        func invokeCancelUploads(_ swiftCallbackInterface: OnGleanEvents, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            swiftCallbackInterface.cancelUploads()
            return RustBuffer()
            // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }

        let cb = try! FfiConverterCallbackInterfaceOnGleanEvents.lift(handle)
        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceOnGleanEvents.drop(handle: handle)
            // No return value.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 0
        case 1:
            let buffer = try! invokeOnInitializeFinished(cb, args)
            out_buf.pointee = buffer
            // Value written to out buffer.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 1
        case 2:
            let buffer = try! invokeTriggerUpload(cb, args)
            out_buf.pointee = buffer
            // Value written to out buffer.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 1
        case 3:
            let buffer = try! invokeStartMetricsPingScheduler(cb, args)
            out_buf.pointee = buffer
            // Value written to out buffer.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 1
        case 4:
            let buffer = try! invokeCancelUploads(cb, args)
            out_buf.pointee = buffer
            // Value written to out buffer.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 1

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return -1
        }
    }

// FFIConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceOnGleanEvents {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_glean_b8a5_OnGleanEvents_init_callback(foreignCallbackCallbackInterfaceOnGleanEvents, err)
        }
    }

    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: Handle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = ConcurrentHandleMap<OnGleanEvents>()
}

extension FfiConverterCallbackInterfaceOnGleanEvents: FfiConverter {
    typealias SwiftType = OnGleanEvents
    // We can use Handle as the FFIType because it's a typealias to UInt64
    typealias FfiType = Handle

    static func lift(_ handle: Handle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    static func read(from buf: Reader) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: Handle = try buf.readInt()
        return try lift(handle)
    }

    static func lower(_ v: SwiftType) -> Handle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    static func write(_ v: SwiftType, into buf: Writer) {
        ensureCallbackinitialized()
        buf.writeInt(lower(v))
    }
}

private struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterUInt32.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterInt32.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterInt64.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterBool.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterString.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDatetime: FfiConverterRustBuffer {
    typealias SwiftType = Datetime?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeDatetime.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDatetime.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDistributionData: FfiConverterRustBuffer {
    typealias SwiftType = DistributionData?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeDistributionData.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDistributionData.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeRate: FfiConverterRustBuffer {
    typealias SwiftType = Rate?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeRate.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRate.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeRecordedExperiment: FfiConverterRustBuffer {
    typealias SwiftType = RecordedExperiment?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeRecordedExperiment.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRecordedExperiment.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterSequenceString.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeRecordedEvent: FfiConverterRustBuffer {
    typealias SwiftType = [RecordedEvent]?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterSequenceTypeRecordedEvent.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRecordedEvent.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterDictionaryStringString.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    static func write(_ value: [UInt8], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterUInt8.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [UInt8] {
        let len: Int32 = try buf.readInt()
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceInt64: FfiConverterRustBuffer {
    typealias SwiftType = [Int64]

    static func write(_ value: [Int64], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterInt64.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [Int64] {
        let len: Int32 = try buf.readInt()
        var seq = [Int64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterInt64.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    static func write(_ value: [String], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterString.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [String] {
        let len: Int32 = try buf.readInt()
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeCommonMetricData: FfiConverterRustBuffer {
    typealias SwiftType = [CommonMetricData]

    static func write(_ value: [CommonMetricData], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeCommonMetricData.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [CommonMetricData] {
        let len: Int32 = try buf.readInt()
        var seq = [CommonMetricData]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCommonMetricData.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeRecordedEvent: FfiConverterRustBuffer {
    typealias SwiftType = [RecordedEvent]

    static func write(_ value: [RecordedEvent], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeRecordedEvent.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [RecordedEvent] {
        let len: Int32 = try buf.readInt()
        var seq = [RecordedEvent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRecordedEvent.read(from: buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryInt64Int64: FfiConverterRustBuffer {
    fileprivate static func write(_ value: [Int64: Int64], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            FfiConverterInt64.write(key, into: buf)
            FfiConverterInt64.write(value, into: buf)
        }
    }

    fileprivate static func read(from buf: Reader) throws -> [Int64: Int64] {
        let len: Int32 = try buf.readInt()
        var dict = [Int64: Int64]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterInt64.read(from: buf)
            let value = try FfiConverterInt64.read(from: buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    fileprivate static func write(_ value: [String: String], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            FfiConverterString.write(key, into: buf)
            FfiConverterString.write(value, into: buf)
        }
    }

    fileprivate static func read(from buf: Reader) throws -> [String: String] {
        let len: Int32 = try buf.readInt()
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: buf)
            let value = try FfiConverterString.read(from: buf)
            dict[key] = value
        }
        return dict
    }
}

public func gleanEnableLogging() {
    try!

        rustCall {
            glean_b8a5_glean_enable_logging($0)
        }
}

public func gleanEnableLoggingToFd(_ fd: UInt64) {
    try!

        rustCall {
            glean_b8a5_glean_enable_logging_to_fd(
                FfiConverterUInt64.lower(fd), $0
            )
        }
}

public func gleanInitialize(_ cfg: InternalConfiguration, _ clientInfo: ClientInfoMetrics, _ callbacks: OnGleanEvents) {
    try!

        rustCall {
            glean_b8a5_glean_initialize(
                FfiConverterTypeInternalConfiguration.lower(cfg),
                FfiConverterTypeClientInfoMetrics.lower(clientInfo),
                FfiConverterCallbackInterfaceOnGleanEvents.lower(callbacks), $0
            )
        }
}

public func gleanInitializeForSubprocess(_ cfg: InternalConfiguration) -> Bool {
    return try! FfiConverterBool.lift(
        try!

            rustCall {
                glean_b8a5_glean_initialize_for_subprocess(
                    FfiConverterTypeInternalConfiguration.lower(cfg), $0
                )
            }
    )
}

public func gleanSetUploadEnabled(_ enabled: Bool) {
    try!

        rustCall {
            glean_b8a5_glean_set_upload_enabled(
                FfiConverterBool.lower(enabled), $0
            )
        }
}

public func gleanSetExperimentActive(_ experimentId: String, _ branch: String, _ extra: [String: String]) {
    try!

        rustCall {
            glean_b8a5_glean_set_experiment_active(
                FfiConverterString.lower(experimentId),
                FfiConverterString.lower(branch),
                FfiConverterDictionaryStringString.lower(extra), $0
            )
        }
}

public func gleanSetExperimentInactive(_ experimentId: String) {
    try!

        rustCall {
            glean_b8a5_glean_set_experiment_inactive(
                FfiConverterString.lower(experimentId), $0
            )
        }
}

public func gleanTestGetExperimentData(_ experimentId: String) -> RecordedExperiment? {
    return try! FfiConverterOptionTypeRecordedExperiment.lift(
        try!

            rustCall {
                glean_b8a5_glean_test_get_experiment_data(
                    FfiConverterString.lower(experimentId), $0
                )
            }
    )
}

public func gleanSetDebugViewTag(_ tag: String) -> Bool {
    return try! FfiConverterBool.lift(
        try!

            rustCall {
                glean_b8a5_glean_set_debug_view_tag(
                    FfiConverterString.lower(tag), $0
                )
            }
    )
}

public func gleanSetSourceTags(_ tags: [String]) -> Bool {
    return try! FfiConverterBool.lift(
        try!

            rustCall {
                glean_b8a5_glean_set_source_tags(
                    FfiConverterSequenceString.lower(tags), $0
                )
            }
    )
}

public func gleanSetLogPings(_ value: Bool) {
    try!

        rustCall {
            glean_b8a5_glean_set_log_pings(
                FfiConverterBool.lower(value), $0
            )
        }
}

public func gleanHandleClientActive() {
    try!

        rustCall {
            glean_b8a5_glean_handle_client_active($0)
        }
}

public func gleanHandleClientInactive() {
    try!

        rustCall {
            glean_b8a5_glean_handle_client_inactive($0)
        }
}

public func gleanSubmitPingByName(_ pingName: String, _ reason: String? = nil) {
    try!

        rustCall {
            glean_b8a5_glean_submit_ping_by_name(
                FfiConverterString.lower(pingName),
                FfiConverterOptionString.lower(reason), $0
            )
        }
}

public func gleanSubmitPingByNameSync(_ pingName: String, _ reason: String? = nil) -> Bool {
    return try! FfiConverterBool.lift(
        try!

            rustCall {
                glean_b8a5_glean_submit_ping_by_name_sync(
                    FfiConverterString.lower(pingName),
                    FfiConverterOptionString.lower(reason), $0
                )
            }
    )
}

public func gleanSetTestMode(_ enabled: Bool) {
    try!

        rustCall {
            glean_b8a5_glean_set_test_mode(
                FfiConverterBool.lower(enabled), $0
            )
        }
}

public func gleanTestDestroyGlean(_ clearStores: Bool) {
    try!

        rustCall {
            glean_b8a5_glean_test_destroy_glean(
                FfiConverterBool.lower(clearStores), $0
            )
        }
}

public func gleanSetDirtyFlag(_ flag: Bool) {
    try!

        rustCall {
            glean_b8a5_glean_set_dirty_flag(
                FfiConverterBool.lower(flag), $0
            )
        }
}

public func gleanGetUploadTask() -> PingUploadTask {
    return try! FfiConverterTypePingUploadTask.lift(
        try!

            rustCall {
                glean_b8a5_glean_get_upload_task($0)
            }
    )
}

public func gleanProcessPingUploadResponse(_ uuid: String, _ result: UploadResult) -> UploadTaskAction {
    return try! FfiConverterTypeUploadTaskAction.lift(
        try!

            rustCall {
                glean_b8a5_glean_process_ping_upload_response(
                    FfiConverterString.lower(uuid),
                    FfiConverterTypeUploadResult.lower(result), $0
                )
            }
    )
}

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum GleanLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {}
}
